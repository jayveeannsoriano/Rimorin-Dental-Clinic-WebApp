"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getHourHeightPartialUnit = exports.getNewEventDateFromPosition = exports.getDateFromPosition = exports.HOUR_DIVIDER = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const store_1 = require("../../../context/store");
const luxon_1 = require("luxon");
const enums_1 = require("../../../common/enums");
const EventButton_utils_1 = require("../../eventButton/EventButton.utils");
const common_1 = require("../../../utils/common");
const calendarDays_1 = require("../../../utils/calendarDays");
const react_1 = require("react");
const CurrentHourLine_1 = __importDefault(require("../../currentHourLine/CurrentHourLine"));
const EventButton_1 = __importDefault(require("../../eventButton/EventButton"));
const luxonHelper_1 = __importDefault(require("../../../utils/luxonHelper"));
const renderEvents = (dataset, day) => {
    return dataset.map((eventRaw) => {
        const item = eventRaw.event;
        return ((0, jsx_runtime_1.jsx)(EventButton_1.default, { item: eventRaw, type: enums_1.EVENT_TYPE.NORMAL, meta: item.meta, day: day }, `${item.id}${item.internalID ? item.internalID : ''}`));
    });
};
exports.HOUR_DIVIDER = 4;
const getDateFromPosition = (value, day, config) => {
    let stringValue = String(value);
    stringValue = stringValue.includes('.') ? stringValue : `${stringValue}.0`;
    const [hourStart, minuteStart] = stringValue.split('.');
    return day.setZone(config.timezone).set({
        hour: Number(hourStart),
        minute: Number(`0.${minuteStart}`) * 60,
        second: 0,
        millisecond: 0,
    });
};
exports.getDateFromPosition = getDateFromPosition;
const getNewEventDateFromPosition = (value, day) => {
    let stringValue = String(value);
    stringValue = stringValue.includes('.') ? stringValue : `${stringValue}.0`;
    const [hourStart, minuteStart] = stringValue.split('.');
    return day.set({
        hour: Number(hourStart),
        minute: Number(`0.${minuteStart}`) * 60,
        second: 0,
        millisecond: 0,
    });
};
exports.getNewEventDateFromPosition = getNewEventDateFromPosition;
const getHourHeightPartialUnit = (config) => Number((config.hourHeight / exports.HOUR_DIVIDER).toFixed(0));
exports.getHourHeightPartialUnit = getHourHeightPartialUnit;
const DaysViewOneDay = (props) => {
    var _a;
    const { day, index, data } = props;
    const [store] = (0, react_1.useContext)(store_1.Context);
    const { width, selectedView, config, callbacks, isNewEventOpen, translations, } = store;
    const { onNewEventClick } = callbacks;
    const { isDark, hourHeight } = config;
    const [offsetTop, setOffsetTop] = (0, react_1.useState)(null);
    const [offsetTopEnd, setOffsetTopEnd] = (0, react_1.useState)(null);
    const startAt = (0, react_1.useRef)(null);
    const endAt = (0, react_1.useRef)(null);
    const [startAtState, setStartAt] = (0, react_1.useState)(null);
    const [endAtState, setEndAt] = (0, react_1.useState)(null);
    // const [isDraggingNewEvent, setIsDraggingNewEvent] = useState(false);
    const newEventStartOffset = (0, react_1.useRef)(null);
    const newEventEndOffset = (0, react_1.useRef)(null);
    const startAtRef = (0, react_1.useRef)(null);
    const isDraggingRef = (0, react_1.useRef)(null);
    const isUpdating = (0, react_1.useRef)(false);
    const style = {
        position: 'absolute',
        top: offsetTop,
        height: offsetTopEnd - offsetTop,
        background: store.style.primaryColor,
        width: '100%',
        zIndex: 9,
        borderRadius: 8,
        opacity: 0.8,
    };
    const handleEventClickInternal = (event) => {
        var _a, _b, _c, _d;
        if (isDraggingRef.current || isUpdating.current) {
            return;
        }
        // prevent propagating when clicking on event due to listeners
        if (((_c = (_b = (_a = event.target) === null || _a === void 0 ? void 0 : _a.offsetParent) === null || _b === void 0 ? void 0 : _b.className) === null || _c === void 0 ? void 0 : _c.indexOf('Kalend__button')) !== -1) {
            return;
        }
        if (onNewEventClick) {
            const element = document.querySelector('.Kalend__DayViewOneDay');
            const rect = (element === null || element === void 0 ? void 0 : element.getBoundingClientRect()) ||
                event.target.getBoundingClientRect();
            const y = event.clientY - rect.top;
            const startAtOnClick = (0, exports.getDateFromPosition)(Number((y / hourHeight).toFixed(0)), day, config);
            if (!((_d = startAtOnClick === null || startAtOnClick === void 0 ? void 0 : startAtOnClick.toUTC()) === null || _d === void 0 ? void 0 : _d.toString())) {
                return;
            }
            const endAtOnClick = startAtOnClick.plus({ hour: 1 });
            // Get hour from click event
            const hour = y / hourHeight;
            onNewEventClick({
                day: day.toJSDate(),
                hour,
                startAt: startAtOnClick === null || startAtOnClick === void 0 ? void 0 : startAtOnClick.toUTC().toString(),
                endAt: endAtOnClick === null || endAtOnClick === void 0 ? void 0 : endAtOnClick.toUTC().toString(),
                event,
                view: selectedView,
            }, event);
        }
    };
    const onMove = (e) => {
        var _a, _b;
        isDraggingRef.current = true;
        // setIsDraggingNewEvent(true);
        e.preventDefault();
        e.stopPropagation();
        if ((0, EventButton_utils_1.disableTouchDragging)(e)) {
            return;
        }
        // Get column element for day, where event is placed
        const dayElement = document.getElementById(`Kalend__day__${day.toString()}`);
        const touches = (_b = (_a = e.nativeEvent) === null || _a === void 0 ? void 0 : _a.touches) === null || _b === void 0 ? void 0 : _b[0];
        const dayElementRect = dayElement.getBoundingClientRect();
        let y;
        // handle touch movement
        if (touches) {
            y = touches.clientY - dayElementRect.top;
        }
        else {
            // handle mouse movement
            y = e.clientY - dayElementRect.top;
        }
        // initial dragging
        if (newEventStartOffset.current === null) {
            const yString = (y / (0, exports.getHourHeightPartialUnit)(config))
                .toFixed(0)
                .split('.');
            const yValue = Number(yString[0]) * (0, exports.getHourHeightPartialUnit)(config);
            setOffsetTop(yValue);
            const startAtValue = (0, exports.getDateFromPosition)(yValue / hourHeight, day, config);
            startAtRef.current = startAtValue;
            startAt.current = startAtValue;
            setStartAt(startAtValue);
            setOffsetTop(yValue);
            setOffsetTopEnd(yValue);
            newEventStartOffset.current = yValue;
            newEventEndOffset.current = yValue;
            startAtRef.current = startAtValue;
            endAt.current = startAtValue;
            setEndAt(startAtValue);
            return;
        }
        // handle dragging up
        if (newEventStartOffset.current && y < newEventStartOffset.current) {
            const yString = (y / (0, exports.getHourHeightPartialUnit)(config))
                .toFixed(0)
                .split('.');
            const yValue = Number(yString[0]) * (0, exports.getHourHeightPartialUnit)(config);
            setOffsetTop(yValue);
            const startAtValue = (0, exports.getDateFromPosition)(yValue / hourHeight, day, config);
            startAtRef.current = startAtValue;
            startAt.current = startAtValue;
            setStartAt(startAtValue);
            return;
        }
        // handle dragging down
        const yString = (y / (0, exports.getHourHeightPartialUnit)(config))
            .toFixed(0)
            .split('.');
        const yValue = Number(yString[0]) * (0, exports.getHourHeightPartialUnit)(config);
        setOffsetTopEnd(yValue);
        const endAtValue = (0, exports.getDateFromPosition)(yValue / hourHeight, day, config);
        endAt.current = endAtValue;
        setEndAt(endAtValue);
    };
    /**
     * Cancel dragging event
     * remove listeners clean long click timeout and reset state
     * @param event
     */
    const onMouseUp = (event) => {
        var _a, _b, _c, _d, _e, _f, _g;
        event.stopPropagation();
        event.preventDefault();
        // clean listeners
        document.removeEventListener('mouseup', onMouseUp, true);
        document.removeEventListener('mousemove', onMove, true);
        const targetClass = event.target.className;
        // prevent propagating when clicking on event due to listeners
        if (((_c = (_b = (_a = event.target) === null || _a === void 0 ? void 0 : _a.offsetParent) === null || _b === void 0 ? void 0 : _b.className) === null || _c === void 0 ? void 0 : _c.indexOf('Kalend__button')) !== -1) {
            return;
        }
        // prevent propagating when clicking on event due to listeners
        if (targetClass.indexOf('Kalend__Event') !== -1) {
            return;
        }
        if (!isDraggingRef.current) {
            handleEventClickInternal(event);
            return;
        }
        // correct layout with actual value from endAt date
        if (endAt) {
            const correctedValue = (endAt.hour + endAt.minute / 60) * hourHeight;
            newEventEndOffset.current = correctedValue;
            setOffsetTopEnd(correctedValue);
        }
        if (isUpdating.current) {
            return;
        }
        if (onNewEventClick && isDraggingRef.current) {
            const startValue = offsetTop / hourHeight;
            isUpdating.current = true;
            if (!((_e = (_d = startAt === null || startAt === void 0 ? void 0 : startAt.current) === null || _d === void 0 ? void 0 : _d.toUTC()) === null || _e === void 0 ? void 0 : _e.toString())) {
                isDraggingRef.current = false;
                isUpdating.current = false;
                return;
            }
            onNewEventClick({
                day: day.toJSDate(),
                hour: startValue,
                event,
                startAt: (_f = startAt.current) === null || _f === void 0 ? void 0 : _f.toUTC().toString(),
                endAt: (_g = endAt.current) === null || _g === void 0 ? void 0 : _g.toUTC().toString(),
                view: selectedView,
            }, event);
        }
        isDraggingRef.current = false;
        isUpdating.current = false;
    };
    /**
     * Start event dragging on long press/touch
     * Set listeners
     * @param e
     */
    const onMouseDownLong = (e) => {
        if ((0, EventButton_utils_1.disableTouchDragging)(e)) {
            return;
        }
        e.preventDefault();
        e.stopPropagation();
        if (e.button !== 0)
            return;
        document.addEventListener('mousemove', onMove, true);
        document.addEventListener('mouseup', onMouseUp, true);
    };
    /**
     * Initial long press click/touch on event
     * @param e
     */
    const onMouseDown = (e) => {
        e.preventDefault();
        e.stopPropagation();
        // if (isDraggingRef.current) {
        //   onMouseUp(e);
        //   return;
        // }
        onMouseDownLong(e);
    };
    const oneDayStyle = {
        width: width / (0, calendarDays_1.getDaysNum)(selectedView),
        height: hourHeight * 24,
    };
    const isToday = luxonHelper_1.default.isToday(day);
    const isFirstDay = index === 0;
    const dataForDay = data;
    const dateNow = luxon_1.DateTime.local();
    const nowPosition = dateNow
        .diff(luxon_1.DateTime.local().set({ hour: 0, minute: 0, second: 0 }), 'minutes')
        .toObject().minutes /
        (60 / hourHeight);
    (0, react_1.useEffect)(() => {
        if (!store.config.autoScroll) {
            return;
        }
        if (isToday) {
            const elements = document.querySelectorAll('.calendar-body__wrapper');
            for (const element of elements) {
                element.scrollTo({ top: nowPosition - 40, behavior: 'smooth' });
            }
        }
    }, []);
    const handleCloseNewEventDrag = (e) => {
        if (e) {
            e.preventDefault();
            e.stopPropagation();
        }
        setOffsetTopEnd(null);
        setOffsetTop(null);
        // setIsDraggingNewEvent(false);
        isDraggingRef.current = false;
        newEventStartOffset.current = null;
        newEventEndOffset.current = null;
        startAt.current = null;
        endAt.current = null;
        setStartAt(null);
        setEndAt(null);
        isUpdating.current = false;
    };
    (0, react_1.useEffect)(() => {
        if (!isNewEventOpen) {
            handleCloseNewEventDrag();
        }
    }, [isNewEventOpen]);
    return ((0, jsx_runtime_1.jsxs)("div", Object.assign({ id: `Kalend__day__${day.toString()}`, style: oneDayStyle, onMouseDown: onMouseDown, onMouseUp: onMouseUp, 
        // onTouchStart={onMouseDown}
        // onTouchMove={onMove}
        // onTouchEnd={onMouseUp}
        className: !isFirstDay
            ? (0, common_1.parseCssDark)('Kalend__DayViewOneDay', isDark)
            : 'Kalend__DayViewOneDay' }, { children: [isToday && config.showTimeLine ? (0, jsx_runtime_1.jsx)(CurrentHourLine_1.default, {}) : null, ((_a = store.daysViewLayout) === null || _a === void 0 ? void 0 : _a[(0, common_1.formatDateTimeToString)(day)]) &&
                dataForDay &&
                dataForDay.length > 0
                ? renderEvents(dataForDay, day)
                : null, isDraggingRef.current ? ((0, jsx_runtime_1.jsx)("div", { style: {
                    width: '100%',
                    height: '100%',
                    background: 'transparent',
                    position: 'fixed',
                    top: 0,
                    left: 0,
                    zIndex: 8,
                }, onClick: handleCloseNewEventDrag })) : null, isDraggingRef.current ? ((0, jsx_runtime_1.jsx)("div", Object.assign({ style: style, className: 'Kalend__NewEvent' }, { children: (0, jsx_runtime_1.jsxs)("div", Object.assign({ style: {
                        paddingTop: 4,
                        paddingLeft: 4,
                        fontSize: 12,
                    } }, { children: [(0, jsx_runtime_1.jsx)("p", Object.assign({ style: { color: 'white' } }, { children: config.newEventText
                                ? config.newEventText
                                : translations['buttons']['newEvent'] })), (0, jsx_runtime_1.jsxs)("p", Object.assign({ style: { color: 'white' } }, { children: [startAtState ? startAtState.toFormat('HH:mm') : '', " -", ' ', endAtState ? endAtState.toFormat('HH:mm') : ''] }))] })) }))) : null] }), day.toString()));
};
exports.default = DaysViewOneDay;
