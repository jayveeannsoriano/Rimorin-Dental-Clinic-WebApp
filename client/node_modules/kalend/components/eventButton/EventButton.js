"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkIfColorDark = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const store_1 = require("../../context/store");
const luxon_1 = require("luxon");
const constants_1 = require("../../common/constants");
const enums_1 = require("../../common/enums");
const draggingHeader_1 = require("./utils/draggingHeader");
const draggingMonth_1 = require("./utils/draggingMonth");
const draggingMonthMore_1 = require("./utils/draggingMonthMore");
const draggingWeek_1 = require("./utils/draggingWeek");
const common_1 = require("../../utils/common");
const EventButton_utils_1 = require("./EventButton.utils");
const draggingGeneral_1 = require("./utils/draggingGeneral");
const calendarDays_1 = require("../../utils/calendarDays");
const ButtonBase_1 = __importDefault(require("../buttonBase/ButtonBase"));
const color_1 = __importDefault(require("color"));
const EventAgenda_1 = __importDefault(require("./eventAgenda/EventAgenda"));
const EventMonth_1 = __importDefault(require("./eventMonth/EventMonth"));
const EventNormal_1 = __importDefault(require("./eventNormal/EventNormal"));
const stateReducer_1 = __importDefault(require("../../utils/stateReducer"));
// ref to cancel timout
let timeoutRef;
const parseAdditionalEventStyle = (event) => {
    if (event.style) {
        return event.style;
    }
    return {};
};
const checkIfColorDark = (colorString) => {
    try {
        const color = (0, color_1.default)(colorString);
        return color.isDark();
    }
    catch (e) {
        return false;
    }
};
exports.checkIfColorDark = checkIfColorDark;
const EventButton = (props) => {
    var _a, _b, _c;
    const { item, type, day = luxon_1.DateTime.now(), index } = props;
    const { event } = item;
    const { startAt, endAt } = event;
    const [state, dispatchState] = (0, react_1.useReducer)(stateReducer_1.default, EventButton_utils_1.eventButtonInitialState);
    const setState = (stateName, data) => {
        const payload = { stateName, data };
        dispatchState({ state, payload });
    };
    // store values as refs to access them in event listener
    const offsetTopRef = (0, react_1.useRef)(state.offsetTop);
    const offsetLeftRef = (0, react_1.useRef)(state.offsetLeft);
    const xShiftIndexRef = (0, react_1.useRef)(0);
    const yShiftIndexRef = (0, react_1.useRef)(0);
    const draggingRef = (0, react_1.useRef)(false);
    const isResizing = (0, react_1.useRef)(false);
    const eventWasChangedRef = (0, react_1.useRef)(false);
    const endAtRef = (0, react_1.useRef)(null);
    const [store, dispatch] = (0, react_1.useContext)(store_1.Context);
    const setContext = (type, payload) => {
        dispatch({ type, payload });
    };
    const { width, calendarDays, config, callbacks, height, draggingDisabledConditions, } = store;
    const { hourHeight, isDark } = config;
    const { onEventClick, onEventDragFinish } = callbacks;
    const columnWidth = width / (type === enums_1.EVENT_TYPE.MONTH ? 7 : calendarDays.length);
    const eventColor = event.color
        ? (0, calendarDays_1.parseEventColor)(event.color, isDark)
        : 'indigo';
    const getPosition = () => {
        if (type === enums_1.EVENT_TYPE.AGENDA) {
            return 'relative';
        }
        else if (type === enums_1.EVENT_TYPE.SHOW_MORE_MONTH && !draggingRef.current) {
            return 'relative';
        }
        else if (type === enums_1.EVENT_TYPE.SHOW_MORE_MONTH) {
            return 'fixed';
        }
        else {
            return 'absolute';
        }
    };
    const isDarkColor = (0, exports.checkIfColorDark)(eventColor);
    const style = Object.assign({ position: getPosition(), height: state.height !== null ? state.height : item.height || constants_1.MONTH_EVENT_HEIGHT, width: state.width !== null ? state.width : item.width || '100%', top: state.offsetTop !== null ? state.offsetTop : item.offsetTop, left: state.offsetLeft !== null ? state.offsetLeft : item.offsetLeft, zIndex: state.zIndex || item.zIndex, border: isDark ? 'solid 1px #1d1f26' : 'solid 1px white', 
        // border: state.zIndex > 2 ? `solid 1px white` : `solid 1px ${eventColor}`,
        backgroundColor: eventColor, visibility: 'visible', color: isDarkColor ? 'white' : 'black' }, parseAdditionalEventStyle(item.event));
    const handleEventClick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        if (draggingRef.current) {
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            draggingRef.current = false;
            return;
        }
        if (onEventClick) {
            onEventClick(event, e);
        }
    };
    const setLayout = (layout) => {
        setState('initialTop', layout.offsetTop);
        setState('initialLeft', layout.offsetLeft);
        setState('offsetTop', layout.offsetTop);
        setState('offsetLeft', layout.offsetLeft);
        setState('drawingY', layout.offsetTop);
        setState('startAt', startAt);
        setState('width', layout.width);
        setState('height', layout.height);
        setState('zIndex', layout.zIndex);
        setState('border', layout.border);
        setState('meta', layout.meta);
    };
    (0, react_1.useEffect)(() => {
        setLayout(item);
        setState('endAt', endAt);
    }, []);
    const initMove = () => {
        if (type === enums_1.EVENT_TYPE.AGENDA) {
            return;
        }
        if (!draggingRef.current) {
            draggingRef.current = true;
        }
        if (type === enums_1.EVENT_TYPE.NORMAL) {
            setState('width', columnWidth - constants_1.EVENT_TABLE_DELIMITER_SPACE);
            setState('offsetLeft', 0);
        }
    };
    const onResize = (e) => {
        e.preventDefault();
        e.stopPropagation();
        if ((0, EventButton_utils_1.disableTouchDragging)(e) || config.disabledDragging) {
            return;
        }
        isResizing.current = true;
        (0, draggingWeek_1.onResizeNormalEvent)(e, endAtRef, day, config, state.offsetTop, state.height, setState);
    };
    const onMove = (e) => {
        e.preventDefault();
        e.stopPropagation();
        if ((0, EventButton_utils_1.disableTouchDragging)(e)) {
            return;
        }
        switch (type) {
            case enums_1.EVENT_TYPE.NORMAL:
                (0, draggingWeek_1.onMoveNormalEvent)(e, draggingRef, day, columnWidth, width, eventWasChangedRef, xShiftIndexRef, offsetLeftRef, offsetTopRef, setState);
                break;
            case enums_1.EVENT_TYPE.HEADER:
                (0, draggingHeader_1.onMoveHeader)(e, columnWidth, width, xShiftIndexRef, offsetLeftRef, eventWasChangedRef, setState);
                break;
            case enums_1.EVENT_TYPE.MONTH:
                (0, draggingMonth_1.onMoveMonthEvent)(e, height, draggingRef, day, columnWidth, width, xShiftIndexRef, yShiftIndexRef, eventWasChangedRef, offsetLeftRef, offsetTopRef, setState, index || 0);
                break;
            case enums_1.EVENT_TYPE.SHOW_MORE_MONTH:
                (0, draggingMonthMore_1.onMoveMonthEventMore)(e, height, draggingRef, day, width, xShiftIndexRef, yShiftIndexRef, eventWasChangedRef, offsetLeftRef, offsetTopRef, setState);
                break;
            default:
                return;
        }
    };
    const onMouseUpResize = (e) => {
        var _a;
        // clean listeners
        document.removeEventListener('mouseup', onMouseUpResize, true);
        document.removeEventListener('mousemove', onResize, true);
        // add data to callback
        if (onEventDragFinish) {
            if (type === enums_1.EVENT_TYPE.NORMAL) {
                const updatedEvent = Object.assign(Object.assign({}, event), { endAt: endAtRef.current || state.endAt });
                const result = (_a = store.events) === null || _a === void 0 ? void 0 : _a.map((item) => {
                    if (item.id === updatedEvent.id) {
                        return updatedEvent;
                    }
                    else {
                        return item;
                    }
                });
                onEventDragFinish(event, updatedEvent, result);
            }
        }
        endAtRef.current = null;
        isResizing.current = false;
        e.preventDefault();
        e.stopPropagation();
    };
    /**
     * Cancel dragging event
     * remove listeners clean long click timeout and reset state
     * @param e
     */
    const onMouseUp = (e) => {
        // clean listeners
        document.removeEventListener('mouseup', onMouseUp, true);
        document.removeEventListener('mousemove', onMove, true);
        // clear timeout
        clearTimeout(timeoutRef);
        if (!eventWasChangedRef.current) {
            setState('offsetLeft', state.offsetLeft);
            setState('width', state.width);
            setState('isDragging', false);
            draggingRef.current = false;
            return;
        }
        eventWasChangedRef.current = false;
        if (!draggingRef.current) {
            return;
        }
        setTimeout(() => {
            draggingRef.current = false;
            setState('isDragging', false);
        }, 100);
        // add data to callback
        if (onEventDragFinish || config.hasExternalLayout) {
            let newEvent = null;
            if (type === enums_1.EVENT_TYPE.NORMAL) {
                newEvent = (0, draggingWeek_1.calculateNewTimeWeekDay)(offsetTopRef.current, offsetLeftRef.current, xShiftIndexRef, event, hourHeight, config);
            }
            else if (type === enums_1.EVENT_TYPE.HEADER) {
                newEvent = (0, draggingHeader_1.calculateHeaderAfterDrag)(calendarDays, event, xShiftIndexRef);
            }
            else if (type === enums_1.EVENT_TYPE.MONTH) {
                newEvent = (0, draggingMonth_1.calculateMonthEventAfterDrag)(calendarDays, yShiftIndexRef, xShiftIndexRef, event);
            }
            else if (type === enums_1.EVENT_TYPE.SHOW_MORE_MONTH) {
                newEvent = (0, draggingMonthMore_1.calculateMonthEventMoreAfterDrag)(calendarDays, yShiftIndexRef, xShiftIndexRef, event);
            }
            if (newEvent) {
                (0, draggingGeneral_1.onFinishDraggingInternal)(event, newEvent, store, setContext, type, onEventDragFinish, () => {
                    setLayout(item);
                });
            }
        }
        e.preventDefault();
        e.stopPropagation();
    };
    const onMouseDownResize = (e) => {
        if ((0, EventButton_utils_1.disableTouchDragging)(e) || !onEventDragFinish) {
            return;
        }
        const isDraggable = (0, common_1.checkIfDraggable)(draggingDisabledConditions, event);
        if (!isDraggable) {
            return;
        }
        e.preventDefault();
        e.stopPropagation();
        isResizing.current = true;
        if (e.button !== 0)
            return;
        document.addEventListener('mousemove', onResize, true);
        document.addEventListener('mouseup', onMouseUpResize, true);
    };
    /**
     * Start event dragging on long press/touch
     * Set listeners
     * @param e
     */
    const onMouseDownLong = (e) => {
        if ((0, EventButton_utils_1.disableTouchDragging)(e)) {
            return;
        }
        const isDraggable = (0, common_1.checkIfDraggable)(draggingDisabledConditions, event);
        if (!isDraggable || config.disabledDragging) {
            return;
        }
        setState('isDragging', true);
        draggingRef.current = true;
        e.preventDefault();
        e.stopPropagation();
        if (e.button !== 0)
            return;
        document.addEventListener('mousemove', onMove, true);
        document.addEventListener('mouseup', onMouseUp, true);
        // set temp state while dragging
        initMove();
    };
    /**
     * Initial long press click/touch on event
     * @param e
     */
    const onMouseDown = (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (isResizing.current) {
            return;
        }
        // add timeout to differentiate from normal clicks
        timeoutRef = setTimeout(() => {
            onMouseDownLong(e);
        }, 120);
    };
    return type !== enums_1.EVENT_TYPE.AGENDA ? ((0, jsx_runtime_1.jsxs)(ButtonBase_1.default, Object.assign({ id: event.id, isDark: isDark, style: style, className: `${(0, common_1.parseCssDark)(`Kalend__Event-${type}`, store.isDark)} ${state.isDragging ? 'Kalend__EventButton__elevation' : ''}`, onClick: handleEventClick, onMouseDown: onMouseDown, onMouseUp: onMouseUp }, { children: [type === enums_1.EVENT_TYPE.MONTH ||
                type === enums_1.EVENT_TYPE.HEADER ||
                type === enums_1.EVENT_TYPE.SHOW_MORE_MONTH ? (((_a = event.children) === null || _a === void 0 ? void 0 : _a.monthView) ? (event.children.monthView) : ((0, jsx_runtime_1.jsx)(EventMonth_1.default, { event: event, isDark: isDark, type: type, isDarkColor: isDarkColor }))) : null, type === enums_1.EVENT_TYPE.NORMAL ? (((_b = event.children) === null || _b === void 0 ? void 0 : _b.daysView) ? (event.children.daysView) : ((0, jsx_runtime_1.jsx)(EventNormal_1.default, { event: event, isDark: isDark, type: type, meta: item.meta, endAt: state.endAt, isDarkColor: isDarkColor, height: item.height }))) : null, isResizing.current ? ((0, jsx_runtime_1.jsx)("div", { className: 'Kalend__EventButton__resizing_wrapper', onClick: () => {
                    isResizing.current = false;
                } })) : null, type === enums_1.EVENT_TYPE.NORMAL ? ((0, jsx_runtime_1.jsx)("div", { style: {
                    position: 'absolute',
                    bottom: 0,
                    height: 5,
                    width: '100%',
                    background: 'transparent',
                    zIndex: isResizing.current ? 999 : 9,
                    cursor: 'n-resize',
                }, onClick: (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    isResizing.current = true;
                }, onMouseDown: onMouseDownResize, onMouseUp: onMouseUpResize })) : null] }))) : ((0, jsx_runtime_1.jsx)(ButtonBase_1.default, Object.assign({ id: event.id, isDark: false, className: (0, common_1.parseCssDark)(`Kalend__Event-${type}`, isDark), onClick: handleEventClick }, { children: ((_c = event.children) === null || _c === void 0 ? void 0 : _c.agendaView) ? (event.children.agendaView) : ((0, jsx_runtime_1.jsx)(EventAgenda_1.default, { event: event, isDark: isDark, type: type })) })));
};
exports.default = EventButton;
