"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.onMoveMonthEventMore = exports.calculateMonthEventMoreAfterDrag = void 0;
const luxon_1 = require("luxon");
const calculateMonthEventMoreAfterDrag = (calendarDays, yShiftIndexRef, xShiftIndexRef, event) => {
    // get new date from x, y coordinates
    // split calendarDays by rows
    const rowCalendarDays = [];
    let tempArray = [];
    calendarDays.forEach((calendarDay) => {
        if (tempArray.length === 7 ||
            (rowCalendarDays.length === 5 && tempArray.length === 6)) {
            tempArray.push(calendarDay);
            rowCalendarDays.push(tempArray);
            tempArray = [];
        }
        tempArray.push(calendarDay);
    });
    // get correct row by y coordinate
    const matchingRow = rowCalendarDays[yShiftIndexRef.current];
    // get day by x coordinate
    const matchingDay = matchingRow[xShiftIndexRef.current];
    const originalStartAtDateTime = luxon_1.DateTime.fromISO(event.startAt);
    const originalEndAtDateTime = luxon_1.DateTime.fromISO(event.endAt);
    const diffInMinutes = originalEndAtDateTime
        .diff(originalStartAtDateTime, 'minutes')
        .toObject().minutes;
    const newStartAt = originalStartAtDateTime.set({
        year: matchingDay.year,
        day: matchingDay.day,
        month: matchingDay.month,
        hour: originalStartAtDateTime.hour,
        minute: originalStartAtDateTime.minute,
    });
    // set correct endAt
    const newEndAt = newStartAt.plus({ minutes: diffInMinutes });
    return Object.assign(Object.assign({}, event), { startAt: newStartAt.toUTC().toString(), endAt: newEndAt.toUTC().toString() });
};
exports.calculateMonthEventMoreAfterDrag = calculateMonthEventMoreAfterDrag;
const onMoveMonthEventMore = (e, height, draggingRef, day, width, xShiftIndexRef, yShiftIndexRef, eventWasChangedRef, offsetLeftRef, offsetTopRef, setState) => {
    var _a, _b;
    const columnHeight = height / 6;
    if (!draggingRef.current) {
        return;
    }
    if (!day) {
        return;
    }
    const tableElement = document.querySelector('.Kalend__Calendar__table');
    const tableElementRect = tableElement.getBoundingClientRect();
    const columnWidth = tableElementRect.width / 7;
    const xTable = e.clientX - tableElementRect.x;
    const yTable = e.clientY - tableElementRect.y;
    // Get column element for day, where event is placed
    const touches = (_b = (_a = e.nativeEvent) === null || _a === void 0 ? void 0 : _a.touches) === null || _b === void 0 ? void 0 : _b[0];
    // set basic coordinates from movement
    let x;
    let y;
    // handle touch movement
    if (touches) {
        x = touches.clientX - tableElementRect.x;
        y = touches.clientY - tableElementRect.y;
    }
    else {
        // calculate x coordinates while following mouse move
        x = e.clientX; // - tableElementRect.x +
        y = e.clientY; //- tableElementRect.y + tableElementRect.left;
    }
    const columnShiftXParsed = parseInt((xTable / columnWidth).toString());
    const columnShiftYParsed = parseInt((yTable / columnHeight).toString());
    setState('width', tableElementRect.width / 7);
    // restrict dragging outside main table
    if (y <= tableElementRect.top ||
        y > tableElementRect.top + tableElementRect.height ||
        x <= tableElementRect.left ||
        x > tableElementRect.width + tableElementRect.left) {
        return;
    }
    xShiftIndexRef.current = columnShiftXParsed;
    yShiftIndexRef.current = columnShiftYParsed;
    setState('offsetLeft', x);
    setState('offsetTop', y);
    eventWasChangedRef.current = true;
    offsetLeftRef.current = x;
    offsetTopRef.current = y;
};
exports.onMoveMonthEventMore = onMoveMonthEventMore;
