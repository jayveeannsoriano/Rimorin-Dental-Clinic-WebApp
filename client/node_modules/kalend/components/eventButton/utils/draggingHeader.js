"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.onMoveHeader = exports.calculateHeaderAfterDrag = void 0;
const constants_1 = require("../../../common/constants");
const luxon_1 = require("luxon");
const calculateHeaderAfterDrag = (calendarDays, event, xShiftIndexRef) => {
    const originalStartAtDateTime = luxon_1.DateTime.fromISO(event.startAt);
    const originalEndAtDateTime = luxon_1.DateTime.fromISO(event.endAt);
    const newDay = calendarDays.map((calendarDay) => calendarDay)[xShiftIndexRef.current];
    const diffInMinutes = originalEndAtDateTime
        .diff(originalStartAtDateTime, 'minutes')
        .toObject().minutes;
    const newStartAt = originalStartAtDateTime.set({
        year: newDay.year,
        day: newDay.day,
        month: newDay.month,
        hour: originalStartAtDateTime.hour,
        minute: originalStartAtDateTime.minute,
    });
    // set correct endAt
    const newEndAt = newStartAt.plus({ minutes: diffInMinutes });
    return Object.assign(Object.assign({}, event), { startAt: newStartAt.toUTC().toString(), endAt: newEndAt.toUTC().toString() });
};
exports.calculateHeaderAfterDrag = calculateHeaderAfterDrag;
const onMoveHeader = (e, columnWidth, width, xShiftIndexRef, offsetLeftRef, eventWasChangedRef, setState) => {
    var _a, _b;
    const tableElement = document.querySelector('.Kalend__Calendar__table');
    const tableElementRect = tableElement.getBoundingClientRect();
    const touches = (_b = (_a = e.nativeEvent) === null || _a === void 0 ? void 0 : _a.touches) === null || _b === void 0 ? void 0 : _b[0];
    // set basic coordinates from movement
    let x;
    // handle touch movement
    if (touches) {
        x = touches.clientX - tableElementRect.x;
    }
    else {
        // calculate x coordinates while following mouse move
        x = e.clientX - tableElementRect.x - constants_1.CALENDAR_OFFSET_LEFT;
    }
    // prevent free dragging across columns with simple recalculation for
    const columnShift = Math.floor(x / columnWidth);
    const xTable = e.clientX - tableElementRect.x; //- CALENDAR_OFFSET_LEFT;
    const columnShiftTable = Math.round(xTable / columnWidth);
    if (columnShiftTable * columnWidth >= width ||
        xTable < 0 ||
        xTable < columnWidth / 2) {
        return;
    }
    // prevent event overflowing on last day
    // TODO reset back after moving left again
    xShiftIndexRef.current = columnShift;
    setState('offsetLeft', columnShift * columnWidth + 1); // add 1 because 0
    // was not working
    eventWasChangedRef.current = true;
    offsetLeftRef.current = x;
};
exports.onMoveHeader = onMoveHeader;
