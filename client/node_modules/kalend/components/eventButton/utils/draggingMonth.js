"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.onMoveMonthEvent = exports.calculateMonthEventAfterDrag = void 0;
const luxon_1 = require("luxon");
const calculateMonthEventAfterDrag = (calendarDays, yShiftIndexRef, xShiftIndexRef, event) => {
    // get new date from x, y coordinates
    // split calendarDays by rows
    const rowCalendarDays = [];
    let tempArray = [];
    calendarDays.forEach((calendarDay) => {
        if (tempArray.length === 7 ||
            (rowCalendarDays.length === 5 && tempArray.length === 6)) {
            tempArray.push(calendarDay);
            rowCalendarDays.push(tempArray);
            tempArray = [];
        }
        tempArray.push(calendarDay);
    });
    // get correct row by y coordinate
    const matchingRow = rowCalendarDays[yShiftIndexRef.current];
    // get day by x coordinate
    const matchingDay = matchingRow[xShiftIndexRef.current];
    const originalStartAtDateTime = luxon_1.DateTime.fromISO(event.startAt);
    const originalEndAtDateTime = luxon_1.DateTime.fromISO(event.endAt);
    const diffInMinutes = originalEndAtDateTime
        .diff(originalStartAtDateTime, 'minutes')
        .toObject().minutes;
    const newStartAt = originalStartAtDateTime.set({
        year: matchingDay.year,
        day: matchingDay.day,
        month: matchingDay.month,
        hour: originalStartAtDateTime.hour,
        minute: originalStartAtDateTime.minute,
    });
    // set correct endAt
    const newEndAt = newStartAt.plus({ minutes: diffInMinutes });
    return Object.assign(Object.assign({}, event), { startAt: newStartAt.toUTC().toString(), endAt: newEndAt.toUTC().toString() });
};
exports.calculateMonthEventAfterDrag = calculateMonthEventAfterDrag;
const onMoveMonthEvent = (e, height, draggingRef, day, columnWidth, width, xShiftIndexRef, yShiftIndexRef, eventWasChangedRef, offsetLeftRef, offsetTopRef, setState, index) => {
    var _a, _b;
    const columnHeight = height / 6;
    if (!draggingRef.current) {
        return;
    }
    if (!day) {
        return;
    }
    const tableElement = document.querySelector('.Kalend__Calendar__table');
    const tableElementRect = tableElement.getBoundingClientRect();
    const xTable = e.clientX - tableElementRect.x;
    const yTable = e.clientY - tableElementRect.y;
    // Get column element for day, where event is placed
    const touches = (_b = (_a = e.nativeEvent) === null || _a === void 0 ? void 0 : _a.touches) === null || _b === void 0 ? void 0 : _b[0];
    // set basic coordinates from movement
    let x;
    let y;
    // handle touch movement
    if (touches) {
        x = touches.clientX - tableElementRect.x;
        y = touches.clientY - tableElementRect.y;
    }
    else {
        // calculate x coordinates while following mouse move
        x = e.clientX - tableElementRect.x;
        y = e.clientY - tableElementRect.y;
    }
    const yReal = yTable - index * columnHeight;
    // prevent free dragging across columns with simple recalculation for
    const columnShiftX = Math.floor(x / columnWidth);
    const columnShiftY = Math.floor(yReal / columnHeight);
    const columnShiftXParsed = parseInt((xTable / columnWidth).toString());
    const columnShiftYParsed = parseInt((yTable / columnHeight).toString());
    const columnShiftTableX = Math.round(xTable / columnWidth);
    if (columnShiftTableX * columnWidth >= width ||
        xTable < 0 ||
        columnShiftY * columnHeight >= height ||
        yTable < 0 ||
        y >= height) {
        return;
    }
    xShiftIndexRef.current = columnShiftXParsed;
    yShiftIndexRef.current = columnShiftYParsed;
    setState('offsetLeft', columnShiftX * columnWidth + 1);
    setState('offsetTop', columnShiftY * columnHeight);
    eventWasChangedRef.current = true;
    offsetLeftRef.current = x;
    offsetTopRef.current = y;
};
exports.onMoveMonthEvent = onMoveMonthEvent;
