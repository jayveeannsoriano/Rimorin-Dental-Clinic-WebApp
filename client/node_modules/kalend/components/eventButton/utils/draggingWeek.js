"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.onResizeNormalEvent = exports.onMoveNormalEvent = exports.calculateNewTimeWeekDay = void 0;
const constants_1 = require("../../../common/constants");
const luxon_1 = require("luxon");
const DaysViewOneDay_1 = require("../../daysViewTable/daysViewOneDay/DaysViewOneDay");
const calculateNewTimeWeekDay = (offsetTopValue, offsetLeftValue, xShiftIndexRef, event, hourHeight, config) => {
    const originalStartAtDateTime = luxon_1.DateTime.fromISO(event.startAt).setZone(config.timezone);
    const originalEndAtDateTime = luxon_1.DateTime.fromISO(event.endAt).setZone(config.timezone);
    let goingForward = false;
    if (offsetLeftValue >= 0) {
        goingForward = true;
    }
    else {
        goingForward = false;
    }
    let newDay;
    if (goingForward) {
        newDay = originalStartAtDateTime.plus({ days: xShiftIndexRef.current });
    }
    else {
        newDay = originalStartAtDateTime.minus({
            days: Math.abs(xShiftIndexRef.current),
        });
    }
    const diffInMinutes = originalEndAtDateTime
        .diff(originalStartAtDateTime, 'minutes')
        .toObject().minutes;
    const minutesOffset = (offsetTopValue / hourHeight) * 60;
    // add minutes calculated from new offset top
    let newStartAt = originalStartAtDateTime
        .set({
        year: newDay.year,
        day: newDay.day,
        month: newDay.month,
        hour: 0,
        minute: 0,
    })
        .plus({ minutes: minutesOffset });
    const topPosition = newStartAt.set({
        hour: 0,
        minute: 0,
        second: 0,
    });
    const offsetTopPosition = topPosition.offset;
    // make offset correction when top position is in different DST zone than
    // startDate
    if (newStartAt.offset !== offsetTopPosition) {
        if (offsetTopPosition > newStartAt.offset) {
            newStartAt = newStartAt.plus({
                minutes: offsetTopPosition - newStartAt.offset,
            });
        }
        else {
            newStartAt = newStartAt.minus({
                minutes: newStartAt.offset - offsetTopPosition,
            });
        }
    }
    // set correct endAt
    const newEndAt = newStartAt.plus({ minutes: diffInMinutes });
    return Object.assign(Object.assign({}, event), { startAt: newStartAt.toUTC().toString(), endAt: newEndAt.toUTC().toString() });
};
exports.calculateNewTimeWeekDay = calculateNewTimeWeekDay;
const onMoveNormalEvent = (e, draggingRef, day, columnWidth, width, eventWasChangedRef, xShiftIndexRef, offsetLeftRef, offsetTopRef, setState) => {
    var _a, _b;
    if (!draggingRef.current) {
        return;
    }
    if (!day) {
        return;
    }
    const tableElement = document.querySelector('.Kalend__Calendar__table');
    const tableElementRect = tableElement.getBoundingClientRect();
    // Get column element for day, where event is placed
    const dayElement = document.getElementById(`Kalend__day__${day.toString()}`);
    if (!dayElement) {
        return;
    }
    const dayElementRect = dayElement.getBoundingClientRect();
    const touches = (_b = (_a = e.nativeEvent) === null || _a === void 0 ? void 0 : _a.touches) === null || _b === void 0 ? void 0 : _b[0];
    // set basic coordinates from movement
    let x;
    let y;
    // handle touch movement
    if (touches) {
        x = touches.clientX - dayElementRect.x;
        y = touches.clientY - dayElementRect.top;
    }
    else {
        // handle mouse movement
        // calculate x and y coordinates while following mouse move
        x = e.clientX - dayElementRect.x;
        y = e.clientY - dayElementRect.top;
    }
    // prevent free dragging across columns with simple recalculation for
    const columnShift = Math.floor(x / columnWidth);
    const xTable = e.clientX - tableElementRect.x;
    const columnShiftTable = Math.round(xTable / columnWidth);
    // restrict draggable space for timetable
    if (y < 0) {
        return;
    }
    eventWasChangedRef.current = true;
    setState('offsetTop', y - constants_1.EVENT_MIN_HEIGHT);
    offsetTopRef.current = y - constants_1.EVENT_MIN_HEIGHT;
    // prevent overflowing on x-axis
    if (columnShiftTable * columnWidth >= width ||
        xTable - constants_1.CALENDAR_OFFSET_LEFT < 0) {
        return;
    }
    xShiftIndexRef.current = columnShift;
    setState('offsetLeft', columnShift * columnWidth);
    offsetLeftRef.current = x;
};
exports.onMoveNormalEvent = onMoveNormalEvent;
const onResizeNormalEvent = (e, endAtRef, day, config, offsetTop, height, setState) => {
    var _a, _b;
    if (!day) {
        return;
    }
    // Get column element for day, where event is placed
    const dayElement = document.getElementById(`Kalend__day__${day.toString()}`);
    if (!dayElement) {
        return;
    }
    const dayElementRect = dayElement.getBoundingClientRect();
    const touches = (_b = (_a = e.nativeEvent) === null || _a === void 0 ? void 0 : _a.touches) === null || _b === void 0 ? void 0 : _b[0];
    // set basic coordinates from movement
    let y;
    // handle touch movement
    if (touches) {
        y = touches.clientY - dayElementRect.top;
    }
    else {
        // handle mouse movement
        y = e.clientY - dayElementRect.top;
    }
    // restrict draggable space for timetable
    if (y < 0) {
        return;
    }
    const yString = (y / (0, DaysViewOneDay_1.getHourHeightPartialUnit)(config)).toFixed(0).split('.');
    const yValue = Number(yString[0]) * (0, DaysViewOneDay_1.getHourHeightPartialUnit)(config);
    const endAtValue = (0, DaysViewOneDay_1.getDateFromPosition)(yValue / config.hourHeight, day, config);
    setState('height', Number(((y - offsetTop) / 15).toFixed(0)) * 15);
    setState('endAt', endAtValue);
    endAtRef.current = endAtValue.toUTC().toString();
};
exports.onResizeNormalEvent = onResizeNormalEvent;
