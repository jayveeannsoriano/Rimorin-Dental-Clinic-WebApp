"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const jsx_runtime_1 = require("react/jsx-runtime");
const common_1 = require("../../utils/common");
const react_1 = require("react");
let timeout;
const ButtonBase = (props) => {
    const { id, onClick, text, className, style, children, propagation, disabled, onClickFromParent, onMouseDown, onMouseUp, onMouseMove, onTouchEnd, isDark, } = props;
    const buttonRef = (0, react_1.useRef)(null);
    const [isPressed, setIsPressed] = (0, react_1.useState)(false);
    const [spanStyle, setSpanStyle] = (0, react_1.useState)({});
    const onButtonClick = (e) => {
        onClick(e);
        if (onClickFromParent) {
            onClickFromParent();
        }
    };
    const animateRipple = (event) => {
        const button = buttonRef.current;
        if (!button) {
            return;
        }
        const rect = button.getBoundingClientRect();
        const oneSide = button.clientWidth > button.clientHeight
            ? button.clientWidth
            : button.clientHeight;
        const touches = event.touches ? event.touches[0] : undefined;
        let clickLeft;
        let clickTop;
        if (touches) {
            clickLeft = touches.clientX - rect.left - oneSide;
            clickTop = touches.clientY - rect.top - oneSide;
        }
        else {
            clickLeft = event.clientX;
            clickTop = event.clientY;
        }
        const style = {
            width: `${oneSide * 2}px`,
            height: `${oneSide * 2}px`,
            left: `${clickLeft}px`,
            top: `${clickTop}px`,
        };
        setSpanStyle(style);
        setIsPressed(true);
    };
    const onTouchStart = (e) => {
        if (!propagation) {
            e.stopPropagation();
        }
        if (props.onTouchStart) {
            props.onTouchStart(e);
        }
        if (isPressed) {
            setIsPressed(false);
        }
        timeout = setTimeout(() => {
            animateRipple(e);
        }, 100);
    };
    // Clear timeout for ripple effect
    const onTouchMove = (e) => {
        if (!propagation) {
            e.stopPropagation();
        }
        if (props.onTouchMove) {
            props.onTouchMove(e);
        }
        clearTimeout(timeout);
    };
    const buttonText = text ? text : '';
    const buttonClassName = className
        ? `Kalend__button ${className} ${(0, common_1.parseCssDark)('Kalend__ButtonBase', isDark)}`
        : `Kalend__button ${(0, common_1.parseCssDark)('Kalend__ButtonBase', isDark)}`;
    return ((0, jsx_runtime_1.jsxs)("button", Object.assign({ id: id, ref: buttonRef, onClick: onButtonClick, onTouchMove: onTouchMove, onTouchStart: onTouchStart, onTouchEnd: onTouchEnd, onMouseDown: onMouseDown, onMouseUp: onMouseUp, onMouseMove: onMouseMove, 
        // onTouchStart={handleTouchStart}
        // onMouseLeave={handleTouchOff}
        // onTouchEnd={handleTouchOff}
        // onTouchEndCapture={handleTouchCancel}
        className: buttonClassName, style: style }, { children: [children ? children : buttonText, isPressed && !disabled ? ((0, jsx_runtime_1.jsx)("span", { style: spanStyle, className: 'Kalend__ButtonBase__animation' })) : null] })));
};
exports.default = ButtonBase;
