"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateMonthPositions = exports.sortByLength = exports.getMonthRows = void 0;
const luxon_1 = require("luxon");
const constants_1 = require("../../../common/constants");
const eventLayout_1 = require("../../../utils/eventLayout");
const common_1 = require("../../../utils/common");
const dateTimeParser_1 = require("../../../utils/dateTimeParser");
const CalendarHeaderEvents_utils_1 = require("../../calendarHeader/calendarHeaderEvents/CalendarHeaderEvents.utils");
const formatOverflowingEvents = (events, timezone) => {
    const result = {};
    if (!events || events.length === 0) {
        return null;
    }
    events.forEach((event) => {
        const dateTimeStartAt = (0, dateTimeParser_1.parseToDateTime)(event.startAt, timezone);
        const dateTimeEndAt = (0, dateTimeParser_1.parseToDateTime)(event.endAt, timezone);
        // get each day for multi day events
        // @ts-ignore
        const differenceInDays = dateTimeEndAt.diff(dateTimeStartAt).days;
        for (let i = 0; i <= differenceInDays; i++) {
            const dateKey = (0, common_1.formatDateTimeToString)(dateTimeStartAt.plus({ days: i }));
            if (!result[dateKey]) {
                result[dateKey] = [event];
            }
            else {
                result[dateKey] = [...result[dateKey], ...[event]];
            }
        }
    });
    return result;
};
const getMonthRows = (calendarDays) => {
    const calendarDaysRows = [];
    let tempArray = [];
    calendarDays.forEach((item, i) => {
        const index = i + 1;
        if (index % 7 === 0) {
            tempArray.push(item);
            calendarDaysRows.push(tempArray);
            tempArray = [];
        }
        else {
            tempArray.push(item);
        }
    });
    return calendarDaysRows;
};
exports.getMonthRows = getMonthRows;
const sortByLength = (events) => {
    return events.sort((a, b) => {
        const diffA = luxon_1.DateTime.fromISO(a.endAt).toMillis() -
            luxon_1.DateTime.fromISO(a.startAt).toMillis();
        const diffB = luxon_1.DateTime.fromISO(b.endAt).toMillis() -
            luxon_1.DateTime.fromISO(b.startAt).toMillis();
        if (diffB > diffA) {
            return 1;
        }
        else if (diffB < diffA) {
            return -1;
        }
        return 0;
    });
};
exports.sortByLength = sortByLength;
const getMonthRowPosition = (events, width, calendarDays, timezone, maxEventsVisible) => {
    var _a;
    const overflowEvents = [];
    const tableSpace = (width / 100) * constants_1.EVENT_TABLE_DELIMITER_SPACE;
    const result = [];
    const usedEvents = [];
    // filter only header events
    const eventsFiltered = [];
    if (!events) {
        return { positions: [], overflowingEvents: [] };
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    (_a = Object.entries(events)) === null || _a === void 0 ? void 0 : _a.map(([key, items]) => {
        // @ts-ignore
        items.forEach((item) => {
            // filter only relevant events
            const isInRange = (0, eventLayout_1.isEventInRange)(item, calendarDays, timezone);
            if (isInRange) {
                // correct position when external event ends in next day
                eventsFiltered.push(item);
            }
        });
    });
    // sort by length to fit more items in limited space
    const sortedByLength = (0, exports.sortByLength)(eventsFiltered);
    // find all matching events to fit in one row
    sortedByLength === null || sortedByLength === void 0 ? void 0 : sortedByLength.forEach((event) => {
        const eventPositionResult = [];
        // check if event was used already
        // skip iteration if event was already resolved
        if (usedEvents.includes(event.id)) {
            return true;
        }
        // set event to row
        const rowWithNotOverlappingEvents = [event];
        usedEvents.push(event.id);
        // compare to rest of the events
        sortedByLength.forEach((eventToCompare) => {
            // check if event was used already
            // skip iteration if event was already resolved
            if (usedEvents.includes(eventToCompare.id)) {
                return true;
            }
            // don't compare to self // maybe remove?
            if (event.id === eventToCompare.id) {
                return true;
            }
            // check if events are not overlapping
            const isOverlapping = (0, eventLayout_1.checkOverlappingEvents)((0, CalendarHeaderEvents_utils_1.stretchHeaderEventTimes)(event, timezone), (0, CalendarHeaderEvents_utils_1.stretchHeaderEventTimes)(eventToCompare, timezone), timezone);
            // found not overlapping matching event
            if (!isOverlapping) {
                let isMatchingAll = true;
                // compare match with other stored events for same row
                rowWithNotOverlappingEvents.forEach((itemFromRow) => {
                    const isOverlappingAll = (0, eventLayout_1.checkOverlappingEvents)((0, CalendarHeaderEvents_utils_1.stretchHeaderEventTimes)(itemFromRow, timezone), (0, CalendarHeaderEvents_utils_1.stretchHeaderEventTimes)(eventToCompare, timezone), timezone);
                    // prevent merging if only one conflict exists
                    if (isOverlappingAll) {
                        isMatchingAll = false;
                    }
                });
                if (isMatchingAll) {
                    // store compared event in used array and add to row
                    usedEvents.push(eventToCompare.id);
                    rowWithNotOverlappingEvents.push(eventToCompare);
                }
            }
        });
        // now we have row with only not overlapping events
        // sort events in row by duration to fit more events in row
        // const sortedResult: CalendarEvent[] = rowWithNotOverlappingEvents.sort(
        //   (a, b) =>
        //     DateTime.fromISO(a.endAt).toMillis() -
        //     DateTime.fromISO(a.startAt).toMillis() -
        //     (DateTime.fromISO(b.endAt).toMillis() -
        //       DateTime.fromISO(b.startAt).toMillis())
        // );
        // const sortedResult = sortByLength(rowWithNotOverlappingEvents);
        // place events accordingly in row next to each other
        rowWithNotOverlappingEvents.forEach((item) => {
            let offset = 0;
            let eventWidth = 0;
            let hasMatchingDay = false;
            calendarDays.forEach((day) => {
                if ((0, eventLayout_1.checkOverlappingDatesForHeaderEvents)(item, day, timezone)) {
                    // set base offset only for first item
                    eventWidth += width;
                    hasMatchingDay = true;
                }
                // increment offset only till we have matching day
                if (!hasMatchingDay) {
                    offset += width;
                }
            });
            const isOverflowing = result.length > maxEventsVisible;
            if (!isOverflowing) {
                // create event position data
                const eventPositionData = {
                    event: item,
                    width: Math.round(eventWidth - tableSpace),
                    offsetLeft: offset,
                    offsetTop: 0,
                    height: 20,
                    zIndex: 2,
                };
                eventPositionResult.push(eventPositionData);
            }
            else {
                overflowEvents.push(item);
            }
        });
        // save row to result
        result.push(eventPositionResult);
    });
    const formattedResult = {};
    result.forEach((events, index) => {
        events.forEach((item) => {
            formattedResult[item.event.id] = Object.assign(Object.assign({}, item), { offsetTop: index * 25 });
        });
    });
    return { positions: formattedResult, overflowingEvents: overflowEvents };
};
const calculateMonthPositions = (events, width, calendarDays, config, maxEventsVisible, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
setContext) => {
    const result = [];
    let overflowingEvents = [];
    // TODO prefilter events for each row
    // split calendar days to rows
    const calendarDaysRows = (0, exports.getMonthRows)(calendarDays);
    // get layout for each row
    calendarDaysRows.forEach((row) => {
        const rowResult = getMonthRowPosition(events, width / 7, row, config.timezone, maxEventsVisible);
        result.push(rowResult.positions);
        overflowingEvents = [...overflowingEvents, ...rowResult.overflowingEvents];
    });
    //
    // setContext(
    //   'monthOverflowEvents',
    //   formatOverflowingEvents(overflowingEvents, config.timezone)
    // );
    return {
        result,
        overflowingEvents: formatOverflowingEvents(overflowingEvents, config.timezone),
    };
};
exports.calculateMonthPositions = calculateMonthPositions;
