"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculatePositionForHeaderEvents = exports.stretchHeaderEventTimes = void 0;
const constants_1 = require("../../../common/constants");
const luxon_1 = require("luxon");
const eventLayout_1 = require("../../../utils/eventLayout");
const common_1 = require("../../../utils/common");
const dateTimeParser_1 = require("../../../utils/dateTimeParser");
// adjust start and end date for header event to full day for correct layout
// calculations
const stretchHeaderEventTimes = (event, timezone) => {
    return Object.assign(Object.assign({}, event), { startAt: (0, dateTimeParser_1.parseToDateTime)(event.startAt, timezone)
            .set({ hour: 0, minute: 0, second: 1 })
            .toString(), endAt: (0, dateTimeParser_1.parseToDateTime)(event.endAt, timezone)
            .set({ hour: 23, minute: 59, second: 59 })
            .toString() });
};
exports.stretchHeaderEventTimes = stretchHeaderEventTimes;
// TODO remove if working without correction
// /**
//  * Find first matching calendarDay for allDay event
//  * Solves problem when layout is wrongly calculated from start and end dates
//  * which are outside of calendarDays range
//  * @param event
//  * @param calendarDays
//  * @param timezone
//  */
// const parseToFirstMatchingCalendarDay = (
//   event: CalendarEvent,
//   calendarDays: DateTime[],
//   timezone: string
// ): CalendarEvent => {
//   const eventClone: CalendarEvent = { ...event };
//   const eventStartDateTime: DateTime = parseToDateTime(
//     event.startAt,
//     event.timezoneStartAt || timezone
//   );
//   let matchingStartDate: DateTime | undefined;
//
//   // find matching date
//   calendarDays.forEach((calendarDay) => {
//     if (!matchingStartDate) {
//       if (LuxonHelper.isSameDay(calendarDay, eventStartDateTime)) {
//         matchingStartDate = calendarDay;
//       }
//     }
//   });
//
//   if (matchingStartDate) {
//     // adjust date for calculations only
//     eventClone.startAt = matchingStartDate
//       .set({
//         hour: eventStartDateTime.hour,
//         minute: eventStartDateTime.minute,
//       })
//       .toUTC()
//       .toString();
//   }
//
//   return eventClone;
// };
const calculatePositionForHeaderEvents = (events, width, calendarDays, timezone, setContext) => {
    // TODO prefilter only relevant events
    // TODO remove used events from main array
    // const formattedDayString: string = formatTimestampToDate(day);
    //
    // const dataForDay: any = events ? events[formattedDayString] : [];
    //
    // const headerEvents: any = renderEvents(calendarBodyWidth, dataForDay);
    //
    // compare each event and find those which can be placed next to each
    // other and are not overlapping
    // form them to row
    var _a;
    const tableSpace = ((width + constants_1.CALENDAR_OFFSET_LEFT) / 100) * constants_1.EVENT_TABLE_DELIMITER_SPACE;
    const result = [];
    const usedEvents = [];
    // filter only header events
    const headerEventsFiltered = [];
    if (!events) {
        return [[]];
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    (_a = Object.entries(events)) === null || _a === void 0 ? void 0 : _a.map(([key, items]) => {
        // @ts-ignore
        items.forEach((item) => {
            // filter only relevant events
            if (item.allDay || (0, common_1.isAllDayEvent)(item, timezone)) {
                const isInRange = (0, eventLayout_1.isEventInRange)(item, calendarDays, timezone);
                if (isInRange) {
                    // correct position when external event ends in next day
                    headerEventsFiltered.push(item);
                }
            }
        });
    });
    // find all matching events to fit in one row
    headerEventsFiltered === null || headerEventsFiltered === void 0 ? void 0 : headerEventsFiltered.forEach((event) => {
        const eventPositionResult = [];
        // check if event was used already
        // skip iteration if event was already resolved
        if (usedEvents.includes(event.id)) {
            return true;
        }
        // set event to row
        const rowWithNotOverlappingEvents = [event];
        usedEvents.push(event.id);
        // compare to rest of the events
        headerEventsFiltered.forEach((eventToCompare) => {
            // check if event was used already
            // skip iteration if event was already resolved
            if (usedEvents.includes(eventToCompare.id)) {
                return true;
            }
            // don't compare to self // maybe remove?
            if (event.id === eventToCompare.id) {
                return true;
            }
            // check if events are not overlapping
            const isOverlapping = (0, eventLayout_1.checkOverlappingEvents)((0, exports.stretchHeaderEventTimes)(event, timezone), (0, exports.stretchHeaderEventTimes)(eventToCompare, timezone), timezone);
            // found not overlapping matching event
            if (!isOverlapping) {
                let isMatchingAll = true;
                // compare match with other stored events for same row
                rowWithNotOverlappingEvents.forEach((itemFromRow) => {
                    const isOverlappingAll = (0, eventLayout_1.checkOverlappingEvents)((0, exports.stretchHeaderEventTimes)(itemFromRow, timezone), (0, exports.stretchHeaderEventTimes)(eventToCompare, timezone), timezone);
                    // prevent merging if only one conflict exists
                    if (isOverlappingAll) {
                        isMatchingAll = false;
                    }
                });
                if (isMatchingAll) {
                    // store compared event in used array and add to row
                    usedEvents.push(eventToCompare.id);
                    rowWithNotOverlappingEvents.push(eventToCompare);
                }
            }
        });
        // now we have row with only not overlapping events
        // sort events in row by start date
        const sortedResult = rowWithNotOverlappingEvents.sort((a, b) => luxon_1.DateTime.fromISO(a.startAt).toMillis() -
            luxon_1.DateTime.fromISO(b.startAt).toMillis());
        // place events accordingly in row next to each other
        sortedResult.forEach((item) => {
            let offset = 0;
            let eventWidth = 0;
            let hasMatchingDay = false;
            calendarDays.forEach((day) => {
                if ((0, eventLayout_1.checkOverlappingDatesForHeaderEvents)(item, day, timezone)) {
                    // set base offset only for first item
                    eventWidth += width;
                    hasMatchingDay = true;
                }
                // increment offset only till we have matching day
                if (!hasMatchingDay) {
                    offset += width;
                }
            });
            // create event position data
            const eventPositionData = {
                event: item,
                width: Math.round(eventWidth - tableSpace),
                offsetLeft: offset + constants_1.CALENDAR_OFFSET_LEFT,
                offsetTop: 0,
                height: 20,
                zIndex: 2,
            };
            eventPositionResult.push(eventPositionData);
        });
        // save row to result
        result.push(eventPositionResult);
    });
    const formattedResult = {};
    result.forEach((events, index) => {
        events.forEach((item) => {
            formattedResult[item.event.id] = Object.assign(Object.assign({}, item), { offsetTop: index * 26 });
        });
    });
    if (setContext) {
        setContext('headerEventRowsCount', result.length);
    }
    return formattedResult;
};
exports.calculatePositionForHeaderEvents = calculatePositionForHeaderEvents;
