"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isEventInRange = exports.checkOverlappingDatesForHeaderEvents = exports.calculateDaysViewLayout = exports.calculateNormalEventPositions = exports.filterEventsByCalendarIDs = exports.checkOverlappingEvents = void 0;
const luxon_1 = require("luxon");
const constants_1 = require("../common/constants");
const calendarDays_1 = require("./calendarDays");
const dateTimeParser_1 = require("./dateTimeParser");
const checkOverlappingEvents = (eventA, eventB, timezone) => {
    const startAtFirst = (0, dateTimeParser_1.parseToDateTime)(eventA.startAt, timezone, timezone);
    const endAtFirst = (0, dateTimeParser_1.parseToDateTime)(eventA.endAt, timezone, timezone);
    const startAtSecond = (0, dateTimeParser_1.parseToDateTime)(eventB.startAt, timezone, timezone);
    const endAtSecond = (0, dateTimeParser_1.parseToDateTime)(eventB.endAt, timezone, timezone);
    return luxon_1.Interval.fromDateTimes(startAtFirst, endAtFirst).overlaps(luxon_1.Interval.fromDateTimes(startAtSecond, endAtSecond));
};
exports.checkOverlappingEvents = checkOverlappingEvents;
const adjustForMinimalHeight = (eventA, eventB, hourHeight) => {
    const result = {
        eventA: Object.assign({}, eventA),
        eventB: Object.assign({}, eventB),
    };
    const eventADiff = 
    // @ts-ignore
    luxon_1.DateTime.fromISO(eventA.endAt)
        .diff(luxon_1.DateTime.fromISO(eventA.startAt))
        .toObject().minutes /
        (60 / hourHeight);
    const eventBDiff = 
    // @ts-ignore
    luxon_1.DateTime.fromISO(eventB.endAt)
        .diff(luxon_1.DateTime.fromISO(eventB.startAt))
        .toObject().minutes /
        (60 / hourHeight);
    if (eventADiff < constants_1.EVENT_MIN_HEIGHT) {
        result.eventA.endAt = luxon_1.DateTime.fromISO(result.eventA.endAt)
            .plus({
            minutes: constants_1.EVENT_MIN_HEIGHT - eventADiff,
        })
            .toString();
    }
    if (eventBDiff < constants_1.EVENT_MIN_HEIGHT) {
        result.eventB.endAt = luxon_1.DateTime.fromISO(result.eventB.endAt)
            .plus({
            minutes: constants_1.EVENT_MIN_HEIGHT - eventBDiff,
        })
            .toString();
    }
    return result;
};
const filterEventsByCalendarIDs = (events, calendarIDsHidden) => {
    if (!calendarIDsHidden || calendarIDsHidden.length === 0) {
        return events;
    }
    return events.filter((item) => {
        if (item.calendarID) {
            if (calendarIDsHidden === null || calendarIDsHidden === void 0 ? void 0 : calendarIDsHidden.includes(item.calendarID)) {
                return false;
            }
            else {
                return item;
            }
        }
        return item;
    });
};
exports.filterEventsByCalendarIDs = filterEventsByCalendarIDs;
const calculateNormalEventPositions = (events, baseWidth, config, selectedView, dateKey) => {
    const result = [];
    let offsetCount = []; //Store every event id of overlapping items
    let offsetCountFinal; //Sort events by id number
    const tableWidth = baseWidth / (0, calendarDays_1.getDaysNum)(selectedView);
    const tableSpace = (tableWidth / 100) * constants_1.EVENT_TABLE_DELIMITER_SPACE;
    if (events) {
        const eventsData = events;
        // Filter all day events and multi day events
        eventsData
            .filter((item) => !item.allDay)
            .map((event) => {
            let width = 1; //Full width
            let offsetLeft = 0;
            // Compare events
            eventsData.forEach((item2) => {
                if (event.id !== item2.id && !item2.allDay) {
                    // adjust events to have at least minimal height to check
                    // overlapping
                    const { eventA, eventB } = adjustForMinimalHeight(event, item2, config.hourHeight);
                    if ((0, exports.checkOverlappingEvents)(eventA, eventB, config.timezone) &&
                        !eventB.allDay) {
                        width = width + 1; //add width for every overlapping item
                        offsetCount.push(item2.id); // set offset for positioning
                        offsetCount.push(event.id); // set offset for positioning
                    }
                }
            });
            const offsetTop = 
            // @ts-ignore
            (0, dateTimeParser_1.parseToDateTime)(event.startAt, config.timezone, config.timezone)
                .diff((0, dateTimeParser_1.parseToDateTime)(event.startAt, config.timezone, config.timezone).set({
                hour: 0,
                minute: 0,
                second: 0,
            }), 'minutes')
                .toObject().minutes /
                (60 / config.hourHeight); // adjust based on hour column height
            const eventHeight = 
            // @ts-ignore
            (0, dateTimeParser_1.parseToDateTime)(event.endAt, config.timezone)
                .diff((0, dateTimeParser_1.parseToDateTime)(event.startAt, config.timezone), 'minutes')
                .toObject().minutes /
                (60 / config.hourHeight); // adjust based on hour column height
            const eventWidth = tableWidth / width;
            //sort items for proper calculations of offset by id
            // prevent different order in loop
            if (offsetCount.length > 0) {
                offsetCountFinal = offsetCount.sort();
            }
            if (offsetCountFinal) {
                offsetLeft = eventWidth * offsetCountFinal.indexOf(event.id); //count offset
            }
            //event.left
            // Current status: events is displayed in wrong place
            offsetCount = [];
            offsetCountFinal = '';
            result.push({
                dateKey,
                event,
                height: eventHeight < constants_1.EVENT_MIN_HEIGHT ? constants_1.EVENT_MIN_HEIGHT : eventHeight,
                width: eventWidth,
                offsetLeft,
                offsetTop,
                zIndex: 2,
                meta: {
                    isFullWidth: width === 1,
                    showTime: eventWidth >= constants_1.SHOW_TIME_THRESHOLD &&
                        eventHeight >= constants_1.SHOW_TIME_THRESHOLD,
                    centerText: eventHeight <= constants_1.SHOW_TIME_THRESHOLD,
                },
            });
        });
    }
    const partialResult = result.map((item) => {
        var _a;
        // full event width
        if ((_a = item.meta) === null || _a === void 0 ? void 0 : _a.isFullWidth) {
            return Object.assign(Object.assign({}, item), { width: Math.round(item.width - tableSpace) });
        }
        else if (item.offsetLeft > 0) {
            return Object.assign(Object.assign({}, item), { width: Math.round(item.width), offsetLeft: item.offsetLeft - tableSpace, zIndex: item.zIndex ? item.zIndex + 2 : 2 });
        }
        else {
            return Object.assign(Object.assign({}, item), { width: Math.round(item.width) });
        }
    });
    return partialResult;
};
exports.calculateNormalEventPositions = calculateNormalEventPositions;
const calculateDaysViewLayout = (calendarDays, events, baseWidth, config, selectedView) => {
    const result = {};
    calendarDays.forEach((calendarDay) => {
        const formattedDayString = calendarDay.toFormat('dd-MM-yyyy');
        const dayEvents = events[formattedDayString];
        const groupedPositions = {};
        const positions = (0, exports.calculateNormalEventPositions)(dayEvents, baseWidth, config, selectedView, formattedDayString);
        positions.forEach((item) => {
            if (groupedPositions[item.event.id]) {
                groupedPositions[item.event.id] = item;
            }
            else {
                groupedPositions[item.event.id] = item;
            }
        });
        result[formattedDayString] = groupedPositions;
    });
    return result;
};
exports.calculateDaysViewLayout = calculateDaysViewLayout;
const checkOverlappingDatesForHeaderEvents = (event, day, timezone) => {
    const dateStart = (0, dateTimeParser_1.parseToDateTime)(event.startAt, timezone);
    const dateEnd = (0, dateTimeParser_1.parseToDateTime)(event.endAt, timezone);
    const dayTruncated = (0, calendarDays_1.parseToDate)(day)
        .set({ hour: 0, minute: 0, millisecond: 0, second: 0 })
        .toMillis();
    const eventStartTruncated = dateStart
        .set({ hour: 0, minute: 0, millisecond: 0, second: 0 })
        .toMillis();
    const eventEndTruncated = dateEnd
        .set({ hour: 0, minute: 0, millisecond: 0, second: 0 })
        .toMillis();
    // fix wrong positioning when external all day event ends in next day
    if (event.externalID) {
        return (dayTruncated >= eventStartTruncated && dayTruncated < eventEndTruncated);
    }
    else {
        return (dayTruncated >= eventStartTruncated && dayTruncated <= eventEndTruncated);
    }
};
exports.checkOverlappingDatesForHeaderEvents = checkOverlappingDatesForHeaderEvents;
const isEventInRange = (event, days, timezone) => {
    let hasMatch = false;
    for (const day of days) {
        if ((0, exports.checkOverlappingDatesForHeaderEvents)(event, day, timezone)) {
            hasMatch = true;
            return true;
            // return false;
        }
    }
    return hasMatch;
};
exports.isEventInRange = isEventInRange;
