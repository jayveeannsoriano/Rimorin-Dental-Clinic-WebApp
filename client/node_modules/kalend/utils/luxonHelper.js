"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DatetimeParser = exports.EVENTS_DAY_FORMAT = exports.DATE_MONTH_YEAR_FORMAT = exports.WEEK_DAY_FORMAT_SHORT = exports.WEEK_DAY_FORMAT_MEDIUM = exports.WEEK_DAY_FORMAT = exports.DATE_DAY_FORMAT = exports.TIME_FORMAT = exports.DATE_FORMAT = exports.DATE_HOUR_FORMAT = exports.TIMESTAMP_FORMAT = void 0;
const luxon_1 = require("luxon");
//
// Support for local datetime, timezones and floating times
//
const FLOATING_DATETIME = 'floating'; // fixed datetime without timezone
const UTC_TIMEZONE = 'UTC';
exports.TIMESTAMP_FORMAT = "yyyy-MM-dd HH:mm:ss 'Z'";
exports.DATE_HOUR_FORMAT = 'd. MMM, HH:mm';
exports.DATE_FORMAT = 'd. MMMM';
exports.TIME_FORMAT = 'HH:mm';
exports.DATE_DAY_FORMAT = 'd. MMMM (EEEEEE)';
exports.WEEK_DAY_FORMAT = 'cccc';
exports.WEEK_DAY_FORMAT_MEDIUM = 'ccc';
exports.WEEK_DAY_FORMAT_SHORT = 'EEEEEE';
exports.DATE_MONTH_YEAR_FORMAT = 'd. MMMM yyyy';
exports.EVENTS_DAY_FORMAT = 'dd-MM-yyyy';
/**
 * Parse datetime according different rules like local datetime, floating time and timezones
 * @param date
 * @param zone
 * @param deviceTimezone
 * @constructor
 */
const DatetimeParser = (date, zone, deviceTimezone) => {
    const dateString = typeof date === 'string' ? date : date.toString();
    const isFloatingDatetime = zone === FLOATING_DATETIME;
    // Adjust date with timezone so when converted to UTC it represents correct value with fixed time
    if (isFloatingDatetime) {
        const dateFloating = luxon_1.DateTime.fromISO(dateString, {
            zone: UTC_TIMEZONE,
        });
        return dateFloating.toUTC().toISO();
    }
    const thisDate = luxon_1.DateTime.fromISO(dateString);
    // Adjust datetime to device timezone
    if (deviceTimezone) {
        const dateConvert = thisDate.setZone(zone);
        return dateConvert.setZone(deviceTimezone).toString();
    }
    return thisDate.setZone(zone).toString();
};
exports.DatetimeParser = DatetimeParser;
const LuxonHelper = {
    parseToDateTime: (date) => typeof date === 'string' ? luxon_1.DateTime.fromISO(date) : date,
    getLastDayOfMonth: (date) => {
        const daysInMonth = date.daysInMonth;
        return date.set({ day: daysInMonth });
    },
    getFirstDayOfMonth: (date) => date.set({ day: 1 }),
    isSameDay: (dateA, dateB) => {
        return (dateA.year === dateB.year &&
            dateA.month === dateB.month &&
            dateA.day === dateB.day);
    },
    isBefore: (dateA, dateB) => luxon_1.DateTime.fromISO(dateB).valueOf() - luxon_1.DateTime.fromISO(dateA).valueOf() > 0,
    isBeforeInDateTime: (dateA, dateB) => dateB.valueOf() - dateA.valueOf() > 0,
    isBeforeAny: (dateA, dateB) => {
        const dateADateTime = LuxonHelper.parseToDateTime(dateA);
        const dateBDateTime = LuxonHelper.parseToDateTime(dateB);
        return dateBDateTime.valueOf() - dateADateTime.valueOf() > 0;
    },
    isToday: (dateA) => {
        const todayDate = luxon_1.DateTime.local();
        return (dateA.day === todayDate.day &&
            dateA.month === todayDate.month &&
            dateA.year === todayDate.year);
    },
    isTodayOrInFuture: (dateA) => {
        const todayDate = luxon_1.DateTime.local();
        return (dateA.day >= todayDate.day &&
            dateA.month === todayDate.month &&
            dateA.year === todayDate.year);
    },
    isSameMonth: (dateA, dateB) => {
        return dateA.month === dateB.month && dateA.year === dateB.year;
    },
    isNearDateOrInFuture: (selectedDate, calendarDay) => {
        return (selectedDate.day >= calendarDay.day &&
            selectedDate.month === calendarDay.month &&
            selectedDate.year === calendarDay.year);
    },
    isCurrentMonth: (dateA) => {
        const todayDate = luxon_1.DateTime.local();
        return dateA.month === todayDate.month && dateA.year === todayDate.year;
    },
    parseToString: (date) => {
        if (typeof date !== 'string') {
            if (date.isValid) {
                return date.toUTC().toString();
            }
        }
        return date.toString();
    },
    toUtcString: (date) => luxon_1.DateTime.fromISO(date).toUTC().toISO(),
    toUtc: (date) => date.toUTC().toISO(),
    setTimezone: (dateString, timezone) => luxon_1.DateTime.fromISO(dateString).setZone(timezone).toString(),
    toHumanDate: (dateString) => luxon_1.DateTime.fromISO(dateString).toFormat('d LLL yyyy hh:mm'),
};
exports.default = LuxonHelper;
