"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isSameMonth = exports.checkIfDraggable = exports.createVerticalHours = exports.getCorrectWidth = exports.eventsToDateKey = exports.eventsToArray = exports.getSelectedViewType = exports.parseCalendarViewToText = exports.isAllDayEvent = exports.getDayTimeEnd = exports.getDayTimeStart = exports.getArrayEnd = exports.getArrayStart = exports.getTableOffset = exports.formatDateTimeToString = exports.formatTimestampToDate = exports.parseClassName = exports.parseIsMobile = exports.parseCssDark = void 0;
const constants_1 = require("../common/constants");
const enums_1 = require("../common/enums");
const luxon_1 = require("luxon");
const dateTimeParser_1 = require("./dateTimeParser");
const parseCssDark = (className, isDark) => {
    if (isDark) {
        return `${className}-dark`;
    }
    return className;
};
exports.parseCssDark = parseCssDark;
const parseIsMobile = (className, isMobile) => {
    return isMobile ? `${className}-mobile` : className;
};
exports.parseIsMobile = parseIsMobile;
const parseClassName = (className, isMobile, isDark) => {
    let classNameParsed = className;
    classNameParsed = isMobile ? `${classNameParsed}-mobile` : classNameParsed;
    classNameParsed = isDark ? `${classNameParsed}-dark` : classNameParsed;
    return classNameParsed;
};
exports.parseClassName = parseClassName;
const formatTimestampToDate = (dateObj) => dateObj.isValid
    ? dateObj.toFormat('dd-MM-yyyy')
    : luxon_1.DateTime.fromISO(dateObj).toFormat('dd-MM-yyyy');
exports.formatTimestampToDate = formatTimestampToDate;
const formatDateTimeToString = (dateObj) => dateObj.toFormat('dd-MM-yyyy');
exports.formatDateTimeToString = formatDateTimeToString;
/**
 * Get left offset for timetable when hours column in used
 * @param calendarView
 * @param showWeekNumbers
 */
const getTableOffset = (calendarView, showWeekNumbers) => {
    if (calendarView === enums_1.CALENDAR_VIEW.MONTH && showWeekNumbers) {
        return 30;
    }
    if (calendarView === enums_1.CALENDAR_VIEW.THREE_DAYS ||
        calendarView === enums_1.CALENDAR_VIEW.DAY ||
        calendarView === enums_1.CALENDAR_VIEW.WEEK) {
        return constants_1.CALENDAR_OFFSET_LEFT;
    }
    return 0;
};
exports.getTableOffset = getTableOffset;
const getArrayStart = (array) => array[0];
exports.getArrayStart = getArrayStart;
const getArrayEnd = (array) => array[array.length - 1];
exports.getArrayEnd = getArrayEnd;
const getDayTimeStart = (date) => date.set({ hour: 0, minute: 0, second: 0 }).toUTC().toString();
exports.getDayTimeStart = getDayTimeStart;
const getDayTimeEnd = (date) => date.set({ hour: 23, minute: 59, second: 59 }).toUTC().toString();
exports.getDayTimeEnd = getDayTimeEnd;
const isAllDayEvent = (item, timezone) => {
    if (!item) {
        return false;
    }
    return (
    // @ts-ignore
    (0, dateTimeParser_1.parseToDateTime)(item.endAt, timezone)
        .diff((0, dateTimeParser_1.parseToDateTime)(item.startAt, timezone), 'days')
        .toObject().days > 1);
};
exports.isAllDayEvent = isAllDayEvent;
const parseCalendarViewToText = (calendarView, translations) => {
    switch (calendarView) {
        case enums_1.CALENDAR_VIEW.AGENDA:
            return translations['buttons']['agenda'];
        case enums_1.CALENDAR_VIEW.DAY:
            return translations['buttons']['day'];
        case enums_1.CALENDAR_VIEW.THREE_DAYS:
            return translations['buttons']['threeDays'];
        case enums_1.CALENDAR_VIEW.WEEK:
            return translations['buttons']['week'];
        case enums_1.CALENDAR_VIEW.MONTH:
            return translations['buttons']['month'];
        default:
            return '';
    }
};
exports.parseCalendarViewToText = parseCalendarViewToText;
const getSelectedViewType = (calendarView) => {
    switch (calendarView) {
        case enums_1.CALENDAR_VIEW.AGENDA:
            return enums_1.CALENDAR_VIEW.AGENDA;
        case enums_1.CALENDAR_VIEW.DAY:
            return enums_1.CALENDAR_VIEW.WEEK;
        case enums_1.CALENDAR_VIEW.THREE_DAYS:
            return enums_1.CALENDAR_VIEW.WEEK;
        case enums_1.CALENDAR_VIEW.WEEK:
            return enums_1.CALENDAR_VIEW.WEEK;
        case enums_1.CALENDAR_VIEW.MONTH:
            return enums_1.CALENDAR_VIEW.MONTH;
        default:
            return '';
    }
};
exports.getSelectedViewType = getSelectedViewType;
const eventsToArray = (events) => {
    let result = [];
    if (!events) {
        return result;
    }
    Object.entries(events).forEach((keyValue) => {
        const eventsItems = keyValue[1];
        result = [...result, ...eventsItems];
    });
    return result;
};
exports.eventsToArray = eventsToArray;
const eventsToDateKey = (events, timezone) => {
    const result = {};
    events === null || events === void 0 ? void 0 : events.forEach((item) => {
        const dateKey = (0, dateTimeParser_1.parseToDateTime)(item.startAt, timezone).toFormat('dd-MM-yyyy');
        if (result[dateKey]) {
            result[dateKey] = [...result[dateKey], ...[item]];
        }
        else {
            result[dateKey] = [item];
        }
    });
    return result;
};
exports.eventsToDateKey = eventsToDateKey;
/**
 * Adjust width for views with displayed scrollbar cutting of space
 * @param width
 * @param isMobile
 * @param selectedView
 */
const getCorrectWidth = (width, isMobile, selectedView) => {
    if (selectedView === enums_1.CALENDAR_VIEW.WEEK ||
        selectedView === enums_1.CALENDAR_VIEW.DAY ||
        selectedView === enums_1.CALENDAR_VIEW.THREE_DAYS) {
        if (isMobile &&
            ('ontouchstart' in window || window.navigator.maxTouchPoints)) {
            return width;
        }
        else {
            return width - constants_1.SCROLLBAR_WIDTH;
        }
    }
    return width;
};
exports.getCorrectWidth = getCorrectWidth;
const createVerticalHours = (timeFormat) => {
    const result = [];
    if (timeFormat === enums_1.TIME_FORMAT.H_24) {
        for (let i = 0; i < 24; i++) {
            if (i < 10) {
                result.push(`0${i}`);
            }
            else {
                result.push(String(i));
            }
        }
    }
    else if (timeFormat === enums_1.TIME_FORMAT.H_12) {
        for (let i = 0; i < 24; i++) {
            if (i < 12) {
                result.push(`${i} AM`);
            }
            else if (i === 12) {
                result.push(`${i} PM`);
            }
            else if (i === 24) {
                result.push(`24 PM`);
            }
            else {
                result.push(`${i - 12} PM`);
            }
        }
    }
    return result;
};
exports.createVerticalHours = createVerticalHours;
const checkIfDraggable = (draggingDisabledConditions, event) => {
    if (!draggingDisabledConditions) {
        return true;
    }
    let result = true;
    Object.entries(draggingDisabledConditions).forEach(([key, value]) => {
        if (event[key]) {
            if (event[key] === value) {
                result = false;
                return false;
            }
        }
    });
    return result;
};
exports.checkIfDraggable = checkIfDraggable;
const isSameMonth = (date) => {
    if (!date) {
        return false;
    }
    const currentDate = luxon_1.DateTime.now();
    return date.month === currentDate.month && date.year === currentDate.year;
};
exports.isSameMonth = isSameMonth;
