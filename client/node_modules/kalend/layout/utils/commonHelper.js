"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRowLayout = exports.DEFAULT_ROW_LAYOUT_RESULT = void 0;
const constants_1 = require("../constants");
const Helper_1 = require("./Helper");
/**
 * Find free slot in day column where to put event
 * @param indexes
 * @param maxEventsVisible
 */
const findFreeSlot = (indexes, maxEventsVisible) => {
    let freeIndex;
    if (!maxEventsVisible || maxEventsVisible <= 0) {
        return -999;
    }
    for (let i = 0; i < maxEventsVisible + 1; i++) {
        if (indexes.length === 0 || !indexes.includes(i)) {
            freeIndex = i;
            return freeIndex;
        }
    }
    return -1;
};
const addEventToResult = (usedIDs, event, takenIndexes, offsetTopIndex, width, headerOffsetTop, tableSpace, dayIndex, result, isHeaderEvents) => {
    usedIDs.push(`${event.id}_${event.internalID}`);
    if (event.daySpawns) {
        event.daySpawns.forEach((daySpawn) => {
            if (takenIndexes[daySpawn]) {
                takenIndexes[daySpawn] = [
                    ...takenIndexes[daySpawn],
                    ...[offsetTopIndex],
                ];
            }
            else {
                takenIndexes[daySpawn] = [offsetTopIndex];
            }
        });
    }
    else {
        if (takenIndexes[event.originDate]) {
            takenIndexes[event.originDate] = [
                ...takenIndexes[event.originDate],
                ...[offsetTopIndex],
            ];
        }
        else {
            takenIndexes[event.originDate] = [offsetTopIndex];
        }
    }
    // spawn width across all days
    const eventWidth = event.daySpawns ? width * event.daySpawns.length : width;
    const eventOffsetTop = 20 * offsetTopIndex;
    if (isHeaderEvents && eventOffsetTop > headerOffsetTop) {
        headerOffsetTop = eventOffsetTop;
    }
    const data = {
        event,
        width: Math.round(eventWidth - tableSpace),
        offsetLeft: dayIndex * width + 2,
        offsetTop: (0, constants_1.getEventHeight)(isHeaderEvents) * offsetTopIndex + offsetTopIndex,
        height: (0, constants_1.getEventHeight)(isHeaderEvents),
        zIndex: 2,
    };
    result.push(data);
    return {
        headerOffsetTop,
        takenIndexes,
    };
};
exports.DEFAULT_ROW_LAYOUT_RESULT = {
    positions: [],
    overflowingEvents: [],
    headerOffsetTop: 0,
};
const addToOverflowingEvents = (event, date, overflowingEvents) => {
    if (overflowingEvents[date]) {
        overflowingEvents[date] = [...overflowingEvents[date], event];
    }
    else {
        overflowingEvents[date] = [event];
    }
};
/**
 * Use for month view and header events
 * @param events
 * @param width
 * @param calendarDays
 * @param timezone
 * @param maxEventsVisible
 * @param isHeaderEvents
 * @param overflowingEvents
 */
const getRowLayout = (events, width, calendarDays, timezone, maxEventsVisible, isHeaderEvents, overflowingEvents) => {
    // store biggest offset top for day view header events
    let headerOffsetTop = 0;
    const tableSpace = (width / 100) * constants_1.EVENT_TABLE_DELIMITER_SPACE;
    const result = [];
    if (!events) {
        return exports.DEFAULT_ROW_LAYOUT_RESULT;
    }
    // prevent adding duplicates from multi-day clones
    const usedIDs = [];
    // store taken indexes under date key
    let takenIndexes = {};
    const calendarDaysDateKey = calendarDays.map((day) => (0, Helper_1.formatToDateKey)(day, timezone));
    calendarDays.forEach((day, dayIndex) => {
        const dateKey = (0, Helper_1.formatToDateKey)(day, timezone);
        // get only events for this day
        const dayEvents = events[dateKey];
        let eventRealIndex = 0; // use basic index for events with free slots
        if (dayEvents) {
            dayEvents.forEach((event) => {
                const takenSlots = takenIndexes[event.originDate];
                // find free slot
                let offsetTopIndex = takenSlots
                    ? findFreeSlot(takenSlots, maxEventsVisible)
                    : eventRealIndex;
                if (!usedIDs.includes(event.id)) {
                    //
                    if (!maxEventsVisible ||
                        maxEventsVisible <= 0 ||
                        eventRealIndex >= maxEventsVisible ||
                        offsetTopIndex >= maxEventsVisible) {
                        offsetTopIndex = -999;
                    }
                    eventRealIndex += 1;
                    // check for overflowing events
                    if (offsetTopIndex === -1 && overflowingEvents) {
                        // save all clones to overflown array
                        if (event.daySpawns) {
                            event.daySpawns.forEach((daySpawn) => {
                                var _a, _b;
                                // check if we can fit spawn to column
                                const takenSlotsSpawn = takenIndexes[daySpawn];
                                // find free slot
                                offsetTopIndex = takenSlotsSpawn
                                    ? findFreeSlot(takenSlotsSpawn, maxEventsVisible)
                                    : 0; // we can use 0 top index as either next day wasn't
                                // iterated yet or takenSlotsSpawn exists for that column
                                if (offsetTopIndex <= -1 && overflowingEvents) {
                                    addToOverflowingEvents(event, daySpawn, overflowingEvents);
                                }
                                else {
                                    const eventAddResult = addEventToResult(usedIDs, Object.assign(Object.assign({}, event), { originDate: daySpawn, daySpawns: (_a = event.daySpawns) === null || _a === void 0 ? void 0 : _a.slice((_b = event.daySpawns) === null || _b === void 0 ? void 0 : _b.indexOf(daySpawn)) }), takenIndexes, offsetTopIndex, width, headerOffsetTop, tableSpace, 
                                    // adjust date index for daySpawn
                                    calendarDaysDateKey.indexOf(daySpawn), result, isHeaderEvents);
                                    headerOffsetTop = eventAddResult.headerOffsetTop;
                                    takenIndexes = eventAddResult.takenIndexes;
                                }
                            });
                        }
                        else {
                            addToOverflowingEvents(event, event.originDate, overflowingEvents);
                        }
                    }
                    else if (offsetTopIndex === -999) {
                        if (event.daySpawns) {
                            event.daySpawns.forEach((daySpawn) => {
                                addToOverflowingEvents(event, daySpawn, overflowingEvents);
                            });
                        }
                        else {
                            addToOverflowingEvents(event, event.originDate, overflowingEvents);
                        }
                    }
                    else {
                        const eventAddResult = addEventToResult(usedIDs, event, takenIndexes, offsetTopIndex, width, headerOffsetTop, tableSpace, dayIndex, result, isHeaderEvents);
                        headerOffsetTop = eventAddResult.headerOffsetTop;
                        takenIndexes = eventAddResult.takenIndexes;
                    }
                }
            });
        }
    });
    return {
        positions: result,
        overflowingEvents,
        headerOffsetTop,
    };
};
exports.getRowLayout = getRowLayout;
