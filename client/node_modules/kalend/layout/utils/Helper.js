"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateEventHeight = exports.calculateOffsetTop = exports.parseTimezone = exports.sortEvents = exports.isEventFloating = exports.parseToCalendarDays = exports.formatToDateKey = void 0;
const luxon_1 = require("luxon");
const LuxonHelper_1 = require("./LuxonHelper");
const formatToDateKey = (date, timezone) => {
    if (!timezone || date.zoneName === timezone) {
        return date.toFormat('dd-MM-yyyy');
    }
    return date.setZone(timezone).toFormat('dd-MM-yyyy');
};
exports.formatToDateKey = formatToDateKey;
const parseToCalendarDays = (calendarDays) => {
    if (typeof calendarDays[0] === 'string') {
        return calendarDays.map((item) => luxon_1.DateTime.fromISO(item));
    }
    return calendarDays;
};
exports.parseToCalendarDays = parseToCalendarDays;
const isEventFloating = (event) => {
    if ((event === null || event === void 0 ? void 0 : event.timezoneStartAt) === 'floating') {
        return true;
    }
    return false;
};
exports.isEventFloating = isEventFloating;
const getRelativeHourHeight = (config) => 60 / config.hourHeight;
const sortEvents = (events) => events.sort((a, b) => {
    return a.startAt.localeCompare(b.startAt);
});
exports.sortEvents = sortEvents;
const getStartDate = (event, config) => (0, LuxonHelper_1.parseToDateTime)(event.startAt, config.timezone, (0, exports.isEventFloating)(event));
const getEndDate = (event, config) => (0, LuxonHelper_1.parseToDateTime)(event.endAt, config.timezone, (0, exports.isEventFloating)(event));
/**
 * Set UTC for floating dates or use config timezone
 * @param timezone
 * @param isFloating
 */
const parseTimezone = (timezone, isFloating) => {
    if (isFloating) {
        return 'UTC';
    }
    return timezone;
};
exports.parseTimezone = parseTimezone;
/**
 * Get offset from top by diff between top position and event starting position
 * @param event
 * @param config
 */
const calculateOffsetTop = (event, config) => {
    let startDate = getStartDate(event, config);
    const topPosition = startDate.set({
        hour: 0,
        minute: 0,
        second: 0,
    });
    const startDateOffset = startDate.offset;
    const topPositionOffset = topPosition.offset;
    // make offset correction when top position is in different DST zone than
    // startDate
    if (startDateOffset !== topPositionOffset) {
        if (topPositionOffset > startDateOffset) {
            startDate = startDate.minus({
                minutes: topPositionOffset - startDateOffset,
            });
        }
        else {
            startDate = startDate.plus({
                minutes: startDateOffset - topPositionOffset,
            });
        }
    }
    const hourHeightValue = getRelativeHourHeight(config);
    const diffInMinutes = startDate
        .diff(topPosition, 'minutes')
        .toObject().minutes;
    if (diffInMinutes) {
        return diffInMinutes / hourHeightValue;
    }
    return 0;
};
exports.calculateOffsetTop = calculateOffsetTop;
/**
 * Get event height by diff in end and start date
 * @param event
 * @param config
 */
const calculateEventHeight = (event, config) => {
    const startDate = getStartDate(event, config);
    const endDate = getEndDate(event, config);
    const diffInMinutes = endDate.diff(startDate, 'minutes').toObject().minutes;
    const hourHeightValue = getRelativeHourHeight(config);
    if (diffInMinutes) {
        return diffInMinutes / hourHeightValue;
    }
    return 0;
};
exports.calculateEventHeight = calculateEventHeight;
