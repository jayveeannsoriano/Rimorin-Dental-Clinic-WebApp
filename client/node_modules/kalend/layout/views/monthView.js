"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMonthViewLayout = exports.prepareMultiDayEvents = exports.parseSingleDay = void 0;
const index_1 = require("../index");
const commonHelper_1 = require("../utils/commonHelper");
const luxon_1 = require("luxon");
const constants_1 = require("../constants");
const LuxonHelper_1 = require("../utils/LuxonHelper");
const Helper_1 = require("../utils/Helper");
const KalendHelper_1 = require("../utils/KalendHelper");
const monthViewHelper_1 = require("../utils/monthViewHelper");
const getBreakPointDateWithZone = (date, config, event) => luxon_1.DateTime.fromFormat(date, 'yyyy-MM-DD').setZone((0, Helper_1.parseTimezone)(config.timezone, (0, Helper_1.isEventFloating)(event)));
const getDiffInDays = (dateTimeStart, dateTimeEnd, event) => {
    let diffInDays = LuxonHelper_1.LuxonHelper.differenceInDays(dateTimeStart, dateTimeEnd);
    // handle overnight events with less than 1 diffInDays
    // but don't adjust behaviour for actual header events with floating
    // timezone
    if (diffInDays === 0 && !(0, Helper_1.isEventFloating)(event)) {
        diffInDays = 1;
    }
    // handle all day events ending at 00:00:00 on next day and display
    // them as single allDay event by subtracting one day from diff in days
    if (diffInDays > 0 &&
        event.timezoneStartAt !== constants_1.FLOATING_DATETIME &&
        dateTimeEnd.hour === 0 &&
        dateTimeEnd.minute === 0 &&
        dateTimeEnd.second === 0) {
        diffInDays = diffInDays - 1;
    }
    return diffInDays;
};
const parseMultiDayEvent = (dateTimeStart, dateTimeEnd, config, event, view, originDate, breakPointDate, preparedEventsPrev) => {
    const diffInDays = getDiffInDays(dateTimeStart, dateTimeEnd, event);
    let daySpawns = [];
    const preparedEvents = Object.assign({}, preparedEventsPrev);
    // flag if events continue in next row
    // split daySpawns and adjust originDate
    for (let i = 0; i <= diffInDays; i++) {
        const refDate = dateTimeStart.plus({ days: i });
        const dateKey = (0, Helper_1.formatToDateKey)(refDate);
        // check if dateKey is same or less than end date
        const endDateDateKey = (0, Helper_1.formatToDateKey)(dateTimeEnd);
        if (luxon_1.DateTime.fromFormat(endDateDateKey, 'dd-MM-yyyy').valueOf() >=
            luxon_1.DateTime.fromFormat(dateKey, 'dd-MM-yyyy').valueOf()) {
            // store each day in multi-day event range
            daySpawns.push(dateKey);
        }
        // break events spawned across multiple rows
        const dateOfWeek = refDate.weekday;
        const weekDayBreakPoint = config.weekDayStart === index_1.WEEKDAY_START.MONDAY ? 7 : 1;
        if (dateOfWeek === weekDayBreakPoint ||
            i === diffInDays ||
            view === index_1.CALENDAR_VIEW.DAY) {
            const eventClone = Object.assign(Object.assign({}, event), { originDate, daysAfter: diffInDays - i });
            eventClone.daySpawns = daySpawns;
            if (view === index_1.CALENDAR_VIEW.DAY) {
                if (!preparedEvents[dateKey]) {
                    preparedEvents[dateKey] = [eventClone];
                }
                else {
                    preparedEvents[dateKey] = [
                        ...preparedEvents[dateKey],
                        ...[eventClone],
                    ];
                }
            }
            else {
                if (!preparedEvents[originDate]) {
                    preparedEvents[originDate] = [eventClone];
                }
                else {
                    preparedEvents[originDate] = [
                        ...preparedEvents[originDate],
                        ...[eventClone],
                    ];
                }
            }
            daySpawns = [];
        }
        let breakPointDateKey = null;
        if (breakPointDate != null) {
            breakPointDateKey = (0, Helper_1.formatToDateKey)(getBreakPointDateWithZone(breakPointDate, config, event), (0, Helper_1.parseTimezone)(config.timezone, (0, Helper_1.isEventFloating)(event)));
        }
        if (((breakPointDateKey && breakPointDateKey === dateKey) ||
            dateOfWeek === weekDayBreakPoint) &&
            i < diffInDays) {
            originDate = (0, Helper_1.formatToDateKey)(refDate.plus({ days: 1 }), (0, Helper_1.parseTimezone)(config.timezone, (0, Helper_1.isEventFloating)(event)));
        }
    }
    return preparedEvents;
};
const parseSingleDay = (event, config, preparedEventsPrev, originDate) => {
    const preparedEvents = Object.assign({}, preparedEventsPrev);
    const dateKey = (0, Helper_1.formatToDateKey)((0, LuxonHelper_1.parseToDateTime)(event.startAt, (0, Helper_1.parseTimezone)(config.timezone, (0, Helper_1.isEventFloating)(event))));
    event.originDate = originDate;
    if (!preparedEvents[dateKey]) {
        preparedEvents[dateKey] = [event];
    }
    else {
        preparedEvents[dateKey] = [...preparedEvents[dateKey], ...[event]];
    }
    return preparedEvents;
};
exports.parseSingleDay = parseSingleDay;
const prepareMultiDayEvents = (events, config, breakPointDate, view) => {
    let preparedEvents = {};
    events.forEach((event) => {
        const { dateTimeStart, dateTimeEnd } = (0, KalendHelper_1.getEventDateTime)(event, config);
        // check if is multi-day
        const isSameDay = LuxonHelper_1.LuxonHelper.isSameDay(dateTimeStart, dateTimeEnd);
        // origin date to determine when event starts in each row
        const originDate = (0, Helper_1.formatToDateKey)(dateTimeStart);
        // handle multi-day
        if (!isSameDay) {
            preparedEvents = parseMultiDayEvent(dateTimeStart, dateTimeEnd, config, event, view, originDate, breakPointDate, preparedEvents);
        }
        else {
            // single day event
            preparedEvents = (0, exports.parseSingleDay)(event, config, preparedEvents, originDate);
        }
    });
    return preparedEvents;
};
exports.prepareMultiDayEvents = prepareMultiDayEvents;
const getMonthViewLayout = (events, width, calendarDays, config, maxEventsVisible, isHeaderEvents) => {
    const result = [];
    // split calendar days to rows
    const calendarDaysRows = (0, monthViewHelper_1.getMonthRows)(calendarDays);
    // Group all events by date key
    // Clone multi-day events to all dates in its range (start from first
    // calendar day and end in last calendar day
    if (!events) {
        return commonHelper_1.DEFAULT_ROW_LAYOUT_RESULT;
    }
    const preparedEvents = (0, exports.prepareMultiDayEvents)(events, config);
    // store max offset top to adjust height of header events parent element
    let headerOffsetTop = 0;
    let overflowingEvents = {};
    // get layout for each row
    calendarDaysRows.forEach((row) => {
        const rowResult = (0, commonHelper_1.getRowLayout)(preparedEvents, width / 7, row, config.timezone, maxEventsVisible, isHeaderEvents, overflowingEvents);
        // store only max value
        if (rowResult.headerOffsetTop > headerOffsetTop) {
            headerOffsetTop = rowResult.headerOffsetTop;
        }
        result.push(rowResult.positions);
        overflowingEvents = rowResult.overflowingEvents;
    });
    return {
        positions: result,
        overflowingEvents,
        headerOffsetTop,
    };
};
exports.getMonthViewLayout = getMonthViewLayout;
