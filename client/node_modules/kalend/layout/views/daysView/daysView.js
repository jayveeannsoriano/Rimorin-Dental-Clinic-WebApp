"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDaysViewLayout = void 0;
const index_1 = require("../../index");
const constants_1 = require("../../constants");
const LuxonHelper_1 = require("../../utils/LuxonHelper");
const headerViewHelper_1 = require("../../utils/headerViewHelper");
const Helper_1 = require("../../utils/Helper");
const KalendHelper_1 = require("../../utils/KalendHelper");
const daysViewHelper_1 = require("./daysViewHelper");
const allDayEvents_1 = require("../../utils/allDayEvents");
const calculateNormalEventPositions = (events, baseWidth, config, selectedView, dateKey) => {
    const result = [];
    if (!(events === null || events === void 0 ? void 0 : events.length)) {
        return result;
    }
    const tableWidth = baseWidth / (0, KalendHelper_1.getDaysNum)(selectedView);
    const tableSpace = (tableWidth / 100) * constants_1.EVENT_TABLE_DELIMITER_SPACE;
    // sort by event start
    const sortedEvents = (0, Helper_1.sortEvents)(events);
    // TODO can be moved to any iteration before to optimize
    // add offset top and height
    const layoutEvents = (0, daysViewHelper_1.getEventsLayouts)(sortedEvents, config);
    // group events based on overlapping
    const layoutGroups = (0, daysViewHelper_1.groupEvents)(layoutEvents);
    // now adjust layout for each event
    layoutGroups.forEach((groups) => {
        const count = groups.length;
        const eventWidth = tableWidth / count;
        groups.forEach((groupItem, index) => {
            const dayViewResult = (0, daysViewHelper_1.parseToDayViewResult)(dateKey, eventWidth, tableWidth, tableSpace, index, groupItem);
            result.push(dayViewResult);
        });
    });
    return result;
};
const calculateDaysViewLayout = (calendarDays, events, baseWidth, config, selectedView) => {
    const result = {};
    calendarDays.forEach((calendarDay) => {
        const formattedDayString = (0, Helper_1.formatToDateKey)(calendarDay, config.timezone);
        const dayEvents = events[formattedDayString];
        result[formattedDayString] = calculateNormalEventPositions(dayEvents, baseWidth, config, selectedView, formattedDayString);
    });
    return result;
};
const filterEvents = (events, config) => {
    // filter to header and normal events
    const headerEvents = {};
    const headerEventsTemp = [];
    const normalEvents = {};
    events.forEach((event) => {
        const { dateTimeStart, dateTimeEnd } = (0, KalendHelper_1.getEventDateTime)(event, config);
        const key = (0, Helper_1.formatToDateKey)(dateTimeStart, (0, Helper_1.parseTimezone)(config.timezone, (0, Helper_1.isEventFloating)(event)));
        // need to store each occurrence
        const daySpawns = [];
        if (event.allDay) {
            headerEventsTemp.push(event);
            if (headerEvents[key]) {
                headerEvents[key] = [...headerEvents[key], ...[event]];
            }
            else {
                headerEvents[key] = [event];
            }
        }
        else {
            // check if start and end on different days
            const isSameDay = LuxonHelper_1.LuxonHelper.isSameDay(dateTimeStart, dateTimeEnd);
            // origin date to determine when event starts in each row
            let originDate = (0, Helper_1.formatToDateKey)(dateTimeStart, (0, Helper_1.parseTimezone)(config.timezone, (0, Helper_1.isEventFloating)(event)));
            // handle multi-day
            if (!isSameDay) {
                for (let i = 0; i <= 1; i++) {
                    const refDate = dateTimeStart.plus({ days: i });
                    originDate = (0, Helper_1.formatToDateKey)(refDate, (0, Helper_1.parseTimezone)(config.timezone, (0, Helper_1.isEventFloating)(event)));
                    const dateKey = (0, Helper_1.formatToDateKey)(refDate, (0, Helper_1.parseTimezone)(config.timezone, (0, Helper_1.isEventFloating)(event)));
                    // store each day in multi-day event range
                    daySpawns.push(dateKey);
                    const eventClone = Object.assign(Object.assign({}, event), { originDate, daysAfter: 1 - i, original: {
                            startAt: event.startAt,
                            endAt: event.endAt,
                        }, startAt: i === 1
                            ? (0, LuxonHelper_1.parseToDateTime)(event.endAt, config.timezone, (0, Helper_1.isEventFloating)(event))
                                .set({ hour: 0, minute: 0, second: 0 })
                                .toUTC()
                                .toString()
                            : event.startAt, endAt: i === 0
                            ? (0, LuxonHelper_1.parseToDateTime)(event.startAt, config.timezone, (0, Helper_1.isEventFloating)(event))
                                .set({ hour: 23, minute: 59, second: 59 })
                                .toUTC()
                                .toString()
                            : event.endAt });
                    eventClone.daySpawns = daySpawns;
                    if (!normalEvents[originDate]) {
                        normalEvents[originDate] = [eventClone];
                    }
                    else {
                        normalEvents[originDate] = [
                            ...normalEvents[originDate],
                            ...[eventClone],
                        ];
                    }
                }
            }
            else if (normalEvents[key]) {
                normalEvents[key] = [...normalEvents[key], event];
            }
            else {
                normalEvents[key] = [event];
            }
        }
    });
    return {
        normalEvents,
        headerEvents,
        headerEventsTemp,
    };
};
const getDaysViewLayout = (events, calendarDays, config, width, selectedView, isMobile) => {
    // add allDay flag to events
    const eventsParsed = (0, allDayEvents_1.parseAllDayEventsArray)(events, config.timezone);
    // filter to header and normal events
    const { headerEventsTemp, normalEvents } = filterEvents(eventsParsed, config);
    const headerPositions = (0, headerViewHelper_1.calculatePositionForHeaderEvents)(headerEventsTemp, (0, KalendHelper_1.getCorrectWidth)(width, isMobile || false, index_1.CALENDAR_VIEW.WEEK), calendarDays, config, selectedView);
    const normalPositions = calculateDaysViewLayout(calendarDays, normalEvents, (0, KalendHelper_1.getCorrectWidth)(width, isMobile || false, index_1.CALENDAR_VIEW.WEEK), config, selectedView);
    return { normalPositions, headerPositions };
};
exports.getDaysViewLayout = getDaysViewLayout;
